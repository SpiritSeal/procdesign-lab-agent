2026-02-19 23:06:31,591 INFO ============================================================
2026-02-19 23:06:31,592 INFO Lab Agent starting
2026-02-19 23:06:31,592 INFO Model (plan):   gemini-3.1-pro-preview
2026-02-19 23:06:31,592 INFO Model (loop):   gemini-3-flash-preview
2026-02-19 23:06:31,592 INFO Edit mode:      full
2026-02-19 23:06:31,592 INFO Assignment dir: /app/assignment
2026-02-19 23:06:31,592 INFO Output dir:     /output
2026-02-19 23:06:31,592 INFO Max iterations: 60
2026-02-19 23:06:31,593 INFO ============================================================
2026-02-19 23:06:31,675 INFO === Stage 1: probing for required files ===
2026-02-19 23:06:31,676 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:06:38,582 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3.1-pro-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:06:38,586 INFO Stage 1 response:
```output
./define.vh
./pipeline.v
./fe_stage.v
./de_stage.v
./agex_stage.v
./sim_main.cpp
```
2026-02-19 23:06:38,586 INFO Files requested by model: ['./define.vh', './pipeline.v', './fe_stage.v', './de_stage.v', './agex_stage.v', './sim_main.cpp']
2026-02-19 23:06:38,587 INFO === Stage 2: generating implementation plan ===
2026-02-19 23:06:38,587 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:09:55,809 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3.1-pro-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:09:55,821 INFO Stage 2 plan:
Here is the complete plan and the exact code modifications needed for implementing the baseline branch predictor as described in the README.

### Plan

1.  **Modify `define.vh`**: 
    - Expand the width of `FE_latch_WIDTH` by 40 bits to accommodate `pht_idx_FE` (8 bits) and `pred_pc_FE` (32 bits).
    - Expand `DE_latch_WIDTH` by 40 bits as well to propagate those fields down the pipeline.
    - Expand `from_AGEX_to_FE_WIDTH` to pass all required update signals back to the FE stage (74 extra bits).

2.  **Modify `fe_stage.v`**: 
    - Instantiate the G-share Branch Predictor state registers: BHR (8 bits), BTB (16 entries), and PHT (256 entries) and properly initialize them.
    - Add prediction logic during instruction fetch to calculate `btb_hit`, `pht_idx`, and use them to route the predicted PC.
    - Include logic within `always @(posedge clk)` to execute the updates sent backward from the AGEX stage.

3.  **Modify `de_stage.v`**:
    - Add wires to extract the newly-passed prediction data (`pht_idx`, `pred_pc`) from the FE latch and pack them into the DE latch to send to AGEX.

4.  **Modify `agex_stage.v`**:
    - Unpack `pht_idx` and `pred_pc` from the DE latch.
    - Implement the correctness check: `br_mispred_AGEX` will trigger if the calculated `br_target_AGEX` differs from `pred_pc`.
    - Create the updated signals (`br_taken`, `br_target_calc`, etc.) to send back to FE for BHR, BTB, and PHT updates.
    - Add performance counters tracking correctly predicted branches and total branches, annotated with `/* verilator public */` so they can be read by `sim_main.cpp`.

5.  **Modify `sim_main.cpp`**:
    - Before finishing the evaluation, access the new public Verilator counters within the AGEX stage instance.
    - Calculate and print the `Accuracy=XX%` string.

---

### File Modifications

#### 1. `./define.vh`
Modify the latch width definitions near the bottom of the file:
```verilog
// ... existing code ...
/** please update the following define with your own values */ 

  `define FE_latch_WIDTH  (1 + `INSTBITS+`DBITS+ `DBITS + `DBITS + 8 + `DBITS) // Added pht_idx (8) and pred_pc (32)
  `define DE_latch_WIDTH  (1 + `INSTBITS+`DBITS+`DBITS+ `IOPBITS + `DBITS + `DBITS + `DBITS + `DBITS + 1 + 1 + 1 + 1 + 1 + `REGNOBITS + 8 + `DBITS) // Added pht_idx and pred_pc

  `define AGEX_latch_WIDTH        (1 + `INSTBITS + `DBITS + `IOPBITS + `DBITS + `DBITS + `DBITS + 1 + 1 + `REGNOBITS + 1)
  `define MEM_latch_WIDTH    (1 + `INSTBITS+`DBITS+ `IOPBITS + `DBITS + `DBITS + `DBITS + 1 + `REGNOBITS) 

  `define from_DE_to_FE_WIDTH  (1) 
  `define from_AGEX_to_FE_WIDTH (1 + `DBITS + 1 + 1 + `DBITS + `DBITS + 8) // mispred(1), target(32), update_BP(1), br_taken(1), calc_target(32), PC_AGEX(32), pht_idx(8)
// ... existing code ...
```

#### 2. `./fe_stage.v`
Update the signal extraction, predictor arrays, prediction logic, and pipeline propagation:
```verilog
// ... existing code ...
  /* pipeline latch */ 
  reg [`FE_latch_WIDTH-1:0] FE_latch;  // FE latch 
  wire valid_FE;
  assign valid_FE = 1'b1; // Explicitly ensure valid_FE is high
   
  `UNUSED_VAR(valid_FE)
  reg [`DBITS-1:0] PC_FE_latch; // PC latch in the FE stage   // you could use a part of FE_latch as a PC latch as well 
  
  reg [`DBITS-1:0] inst_count_FE; /* for debugging purpose */ 
  
  wire [`DBITS-1:0] inst_count_AGEX; /* for debugging purpose. resent the instruction counter */ 

  wire [`INSTBITS-1:0] inst_FE;  // instruction value in the FE stage 
  wire [`DBITS-1:0] pcplus_FE;  // pc plus value in the FE stage 
  wire stall_pipe_FE; // signal to indicate when a front-end needs to be stall
  
  wire [`FE_latch_WIDTH-1:0] FE_latch_contents;  // the signals that will be FE latch contents 
  
  // reading instruction from imem 
  assign inst_FE = imem[PC_FE_latch[`IMEMADDRBITS-1:`IMEMWORDBITS]];  // this code works. imem is stored 4B together 
  
  // wire to send the FE latch contents to the DE stage 
  assign FE_latch_out = FE_latch; 
 
  // This is the value of "incremented PC", computed in the FE stage
  assign pcplus_FE = PC_FE_latch + `INSTSIZE;
  
  // Branch Predictor arrays and prediction wires
  reg [7:0] BHR;
  reg valid_BTB [15:0];
  reg [25:0] tag_BTB [15:0];
  reg [31:0] target_BTB [15:0];
  reg [1:0] PHT [255:0];

  wire [7:0] pht_idx_FE;
  wire [31:0] pred_pc_FE;
  wire [3:0] btb_idx_FE = PC_FE_latch[5:2];
  wire [25:0] btb_tag_FE = PC_FE_latch[31:6];

  assign pht_idx_FE = PC_FE_latch[9:2] ^ BHR;

  wire btb_hit_FE = valid_BTB[btb_idx_FE] && (tag_BTB[btb_idx_FE] == btb_tag_FE);
  wire pht_taken_FE = PHT[pht_idx_FE][1]; // MSB determines taken / not taken

  // Predict Next PC logic
  assign pred_pc_FE = (btb_hit_FE && pht_taken_FE) ? target_BTB[btb_idx_FE] : pcplus_FE;
   
   // the order of latch contents should be matched in the decode stage when we extract the contents. 
  assign FE_latch_contents = {
                                valid_FE, 
                                inst_FE, 
                                PC_FE_latch, 
                                pcplus_FE, // please feel free to add more signals such as valid bits etc. 
                                inst_count_FE,
                                pht_idx_FE,
                                pred_pc_FE
                                };

  wire br_mispred_AGEX;  
  wire [`DBITS-1:0] br_target_AGEX;  
  wire update_BP_AGEX;
  wire br_taken_AGEX;
  wire [`DBITS-1:0] br_target_calc_AGEX;
  wire [`DBITS-1:0] PC_AGEX_BP;
  wire [7:0] pht_idx_AGEX;

  assign {
    stall_pipe_FE
  } = from_DE_to_FE[0]; 

  assign {
    br_mispred_AGEX,
    br_target_AGEX,
    update_BP_AGEX,
    br_taken_AGEX,
    br_target_calc_AGEX,
    PC_AGEX_BP,
    pht_idx_AGEX
  } = from_AGEX_to_FE;

  integer i;
  always @ (posedge clk) begin
   if (reset) begin 
      PC_FE_latch <= `STARTPC;
      inst_count_FE <= 1;
      BHR <= 8'b0;
      for (i=0; i<16; i=i+1) begin
        valid_BTB[i] <= 1'b0;
        tag_BTB[i] <= 26'b0;
        target_BTB[i] <= 32'b0;
      end
      for (i=0; i<256; i=i+1) begin
        PHT[i] <= 2'b01;
      end
    end else begin
      if (br_mispred_AGEX)
        PC_FE_latch <= br_target_AGEX;
      else if (stall_pipe_FE) 
        PC_FE_latch <= PC_FE_latch; 
      else begin 
        PC_FE_latch <= pred_pc_FE;
        inst_count_FE <= inst_count_FE + 1; 
      end 
      
      // Predictor Update Block
      if (update_BP_AGEX) begin
        // Update BHR
        BHR <= {BHR[6:0], br_taken_AGEX};
        // Update BTB
        valid_BTB[PC_AGEX_BP[5:2]] <= 1'b1;
        tag_BTB[PC_AGEX_BP[5:2]] <= PC_AGEX_BP[31:6];
        target_BTB[PC_AGEX_BP[5:2]] <= br_target_calc_AGEX;
        // Update PHT
        if (br_taken_AGEX) begin
          if (PHT[pht_idx_AGEX] != 2'b11)
            PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] + 1;
        end else begin
          if (PHT[pht_idx_AGEX] != 2'b00)
            PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] - 1;
        end
      end
    end
  end
// ... existing code ...
```

#### 3. `./de_stage.v`
Propagate `pht_idx` and `pred_pc` backward and forward:
```verilog
// ... existing code ...
  always @(posedge clk) begin
    if (reset) begin
      in_use_regs <= '0;
    end else begin
      if (~pipeline_stall_DE && wr_reg_DE) begin
        in_use_regs[rd_DE] <= 1;
      end 
      if (wr_reg_WB) begin
        in_use_regs[wregno_WB] <= 0;
      end
    end
  end

  wire [7:0] pht_idx_DE;
  wire [31:0] pred_pc_DE;

// decoding the contents of FE latch out. the order should be matched with the fe_stage.v 
  assign {
            valid_DE,
            inst_DE,
            PC_DE, 
            pcplus_DE,
            inst_count_DE,
            pht_idx_DE,
            pred_pc_DE
            }  = from_FE_latch;  // based on the contents of the latch, you can decode the content 

// assign wire to send the contents of DE latch to other pipeline stages  
  assign DE_latch_out = DE_latch; 

   assign DE_latch_contents = {
                                  valid_DE, 
                                  inst_DE,
                                  PC_DE,
                                  pcplus_DE,
                                  op_I_DE,
                                  inst_count_DE,
                                  // more signals might need
                                  rs1_val_DE,
                                  rs2_val_DE,    
                                  sxt_imm_DE,
                                  is_br_DE,
                                  is_jmp_DE,
                                  rd_mem_DE,
                                  wr_mem_DE,
                                  wr_reg_DE,
                                  rd_DE,
                                  pht_idx_DE,
                                  pred_pc_DE
                                  }; 
// ... existing code ...
```

#### 4. `./agex_stage.v`
Complete and pack prediction checks, updates, and public cycle counters for `sim_main.cpp`:
```verilog
// ... existing code ...
  reg [`DBITS-1:0] aluout_AGEX;
  reg [`DBITS-1:0] memaddr_AGEX;
  reg [`DBITS-1:0] br_target_AGEX;
  wire br_mispred_AGEX;

  wire [7:0] pht_idx_AGEX;
  wire [31:0] pred_pc_AGEX;
// ... existing code (br_cond_AGEX and aluout_AGEX logic remain the same) ...
  // branch target needs to be computed here 
  // computed branch target needs to send to other pipeline stages (br_target_AGEX)
  // TODO: complete the code
  wire [31:0] br_target_calc_AGEX;
  assign br_target_calc_AGEX = (op_I_AGEX == `JAL_I) ? (PC_AGEX + sxt_imm_AGEX) :
                               (op_I_AGEX == `JR_I) ? regval1_AGEX :
                               (op_I_AGEX == `JALR_I) ? ((regval1_AGEX + sxt_imm_AGEX) & 32'hfffffffe) :
                               (is_br_AGEX) ? (PC_AGEX + sxt_imm_AGEX) : pcplus_AGEX;

  always @(*)begin
    if (is_jmp_AGEX || (is_br_AGEX && br_cond_AGEX))
      br_target_AGEX = br_target_calc_AGEX;
    else
      br_target_AGEX = pcplus_AGEX;
  end

  assign br_mispred_AGEX = valid_AGEX && (is_br_AGEX || is_jmp_AGEX) && (br_target_AGEX != pred_pc_AGEX);

  wire update_BP_AGEX = valid_AGEX && (is_br_AGEX || is_jmp_AGEX);
  wire br_taken_AGEX = is_jmp_AGEX || (is_br_AGEX && br_cond_AGEX);

    assign  {                     
                                  valid_AGEX,
                                  inst_AGEX,
                                  PC_AGEX,
                                  pcplus_AGEX,
                                  op_I_AGEX,
                                  inst_count_AGEX,
                                          // more signals might need
                                  regval1_AGEX,
                                  regval2_AGEX,
                                  sxt_imm_AGEX,                                
                                  is_br_AGEX,
                                  is_jmp_AGEX,
                                  rd_mem_AGEX,
                                  wr_mem_AGEX,
                                  wr_reg_AGEX,
                                  wregno_AGEX,
                                  pht_idx_AGEX,
                                  pred_pc_AGEX
                                  } = from_DE_latch; 
// ... existing code ...
  // forward signals to FE stage
  assign from_AGEX_to_FE = { 
    br_mispred_AGEX, 
    br_target_AGEX,
    update_BP_AGEX,
    br_taken_AGEX,
    br_target_calc_AGEX,
    PC_AGEX,
    pht_idx_AGEX
  };

  // forward signals to DE stage
  assign from_AGEX_to_DE = { 
    br_mispred_AGEX
  };

  reg [31:0] bp_correct_cnt /* verilator public */;
  reg [31:0] bp_total_cnt /* verilator public */;

  always @(posedge clk) begin
    if (reset) begin
      bp_correct_cnt <= 0;
      bp_total_cnt <= 0;
    end else if (valid_AGEX && (is_br_AGEX || is_jmp_AGEX)) begin
      bp_total_cnt <= bp_total_cnt + 1;
      if (!br_mispred_AGEX) begin
        bp_correct_cnt <= bp_correct_cnt + 1;
      end
    end
  end

endmodule
```

#### 5. `./sim_main.cpp`
Fetch public counters directly at the end of the simulation iteration loop:
```cpp
// ... existing code ...
#ifdef DPRINTF
    std::cout << "Total instructions=" << std::dec << inst_count_WB << ", cycles=" << (timestamp_WB / 2) << ", IPC=" << ((inst_count_WB * 2.0f) / timestamp_WB) << std::endl; 
#endif

    uint32_t bp_correct = dut->pipeline->my_AGEX_stage->bp_correct_cnt;
    uint32_t bp_total = dut->pipeline->my_AGEX_stage->bp_total_cnt;
    double accuracy = 0.0;
    if (bp_total > 0) accuracy = 100.0 * bp_correct / bp_total;
    std::cout << "Accuracy=" << accuracy << "%" << std::endl;

    int exitcode = (int)dut->pipeline->my_WB_stage->last_WB_value[3];
// ... existing code ...
```
2026-02-19 23:09:55,821 INFO === Stage 3: execution loop (max 60 iterations) ===
2026-02-19 23:09:55,822 INFO --- Iteration 1 ---
2026-02-19 23:09:55,822 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:11:28,685 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:11:28,690 INFO Model:
```read
./wb_stage.v
```

```edit
./define.vh
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
  `define STARTPC   32'h200
  `define WBCOUNTERS  8
  
  //Memory mapped IO
  `define ADDRLEDR  32'hFFFFF020
  `define ADDRKEY   32'hFFFFF080
  `define ADDRSW    32'hFFFFF090

  
// address space is m 0x00000000 to 0x000fffff
  // [NOTICE] please note that both imem and dmem use the SAME "IDMEMINITFILE".
  // you need to change this line to change which test file to read 
  `define IDMEMINITFILE "/home/zhifan/workspace/cs3220-23fall/lab2/test/towers/towers.mem"
  `define IMEMADDRBITS  16
  `define IMEMWORDBITS  2
  `define IMEMWORDS	  (1 << (`IMEMADDRBITS - `IMEMWORDBITS))
  `define DMEMADDRBITS  16
  `define DMEMWORDBITS  2
  `define DMEMWORDS	  (1 << (`DMEMADDRBITS - `DMEMWORDBITS))
   
  `define CSRNOBITS 4
  `define CSR_ID_BIT_MASK 12'hF // this should match with CSRNOBITS 
  `define CSRREGNUM (1 << (`CSRNOBITS))

// internal instruction opcode enumerator for easy programming 

  `define IOPBITS 6
  `define TYPENOBITS 4 
  `define IMMTYPENOBITS 3 

  `define ADD_I    1 
  `define SUB_I    2 
  `define AND_I    3
  `define OR_I     4 
  `define XOR_I    5
  `define SLT_I    6
  `define SLTU_I   7
  `define SRA_I    8
  `define SRL_I    9
  `define SLL_I    10
  `define MUL_I    11
  `define ADDI_I   12 
  `define ANDI_I   13
  `define ORI_I    14
  `define XORI_I   15
  `define SLTI_I   16
  `define SLTIU_I  17
  `define SRAI_I   18
  `define SRLI_I   19
  `define SLLI_I   20
  `define LUI_I    21
  `define AUIPC_I  22
  `define LW_I     23
  `define SW_I     24
  `define JAL_I    25
  `define JR_I     26
  `define JALR_I   27
  `define BEQ_I    28
  `define BNE_I    29
  `define BLT_I    30
  `define BGE_I    31
  `define BLTU_I   32
  `define BGEU_I   33
  `define CSRR_I  34
  `define CSRW_I  35
  `define CSR_I    36
  `define INVALID_I 37 

  `define R_Type 1 
  `define I_Type 2 
  `define S_Type 3 
  `define U_Type 4 
  `define I_I_type 5 
  `define S_I_Type 6
  `define B_I_Type 7
  `define U_I_Type 8
  `define J_I_Type 9 

  `define I_immediate 1 
  `define J_immediate 2
  `define U_immediate 3
  `define S_immediate 4 
  `define B_immediate 5  


  `define CSRR_OPCODE 7'b1110011 
  `define CSRR_FUNCT3 3'b010
  `define CSRW_OPCODE 7'b1110011 
  `define CSRW_FUNCT3 3'b001  

  `define ADD_OPCODE 7'b0110011
  `define ADD_FUNCT3 3'b000
  `define ADD_FUNCT7 7'b0000000 
  `define SUB_OPCODE 7'b0110011
  `define SUB_FUNCT3 3'b000
  `define SUB_FUNCT7 7'b0100000
  `define AND_OPCODE 7'b0110011
  `define AND_FUNCT3 3'b111
  `define AND_FUNCT7 7'b0000000 
  `define OR_OPCODE  7'b0110011
  `define OR_FUNCT3  3'b110
  `define OR_FUNCT7  7'b0000000 
  `define XOR_OPCODE 7'b0110011
  `define XOR_FUNCT3 3'b100
  `define XOR_FUNCT7 7'b0000000 
  `define SLT_OPCODE 7'b0110011
  `define SLT_FUNCT3 3'b010 
  `define SLT_FUNCT7 7'b0000000 
  `define SLTU_OPCODE 7'b0110011
  `define SLTU_FUNCT3 3'b011 
  `define SLTU_FUNCT7 7'b0000000 

  `define SRA_OPCODE 7'b0110011 
  `define SRA_FUNCT3 3'b101 
  `define SRA_FUNCT7 7'b0100000 
  `define SRL_OPCODE 7'b0110011 
  `define SRL_FUNCT3  3'b101
  `define SRL_FUNCT7  7'b0000000 
  `define SLL_OPCODE  7'b0110011 
  `define SLL_FUNCT3  3'b001
  `define SLL_FUNCT7  7'b0000000 
  `define MUL_OPCODE 7'b0110011 
  `define MUL_FUNCT3 3'b000 
  `define MUL_FUNCT7  7'b0000001   
  

  `define ADDI_OPCODE 7'b0010011   
  `define ADDI_FUNCT3 3'b000 
  `define ANDI_OPCODE 7'b0010011 
  `define ANDI_FUNCT3 3'b111
  `define ORI_OPCODE 7'b0010011 
  `define ORI_FUNCT3 3'b110 
  `define XORI_OPCODE 7'b0010011  
  `define XORI_FUNCT3 3'b100 
  `define SLTI_OPCODE 7'b0010011  
  `define SLTI_FUNCT3  3'b010 
  `define SLTIU_OPCODE 7'b0010011 
  `define SLTIU_FUNCT3  3'b011 

  `define SRAI_OPCODE  7'b0010011  
  `define SRAI_FUNCT3   3'b101 
  `define SRAI_FUNCT7  7'b0100000 
  `define SRLI_OPCODE  7'b0010011   
  `define SRLI_FUNCT3  3'b101 
  `define SRLI_FUNCT7  7'b0000000 

  `define SLLI_OPCODE 7'b0010011
  `define SLLI_FUNCT3  3'b001 
  `define SLLI_FUNCT7  7'b0000000   
  `define LUI_OPCODE 7'b0110111 

  `define AUIPC_OPCODE  7'b0010111  

  `define LW_OPCODE  7'b0000011 
  `define LW_FUNCT3  3'b010  
  `define SW_OPCODE 7'b0100011 
  `define SW_FUNCT3 3'b010 

  `define JAL_OPCODE 7'b1101111 
  `define JR_OPCODE  7'b1100111  
  `define JR_FUNCT3 3'b000
  `define JR_10MSB 10'b000000000000    
  `define JALR_OPCODE 7'b1100111    
  `define JALR_FUNCT3  3'b000 

  `define BEQ_OPCODE 7'b1100011  
  `define BEQ_FUNCT3 3'b000
  `define BNE_OPCODE 7'b1100011  
  `define BNE_FUNCT3 3'b001  

  `define BLT_OPCODE 7'b1100011 
  `define BLT_FUNCT3 3'b100
  `define BGE_OPCODE 7'b1100011  
  `define BGE_FUNCT3 3'b101 
  `define BLTU_OPCODE 7'b1100011
  `define BLTU_FUNCT3 3'b110
  `define BGEU_OPCODE 7'b1100011
  `define BGEU_FUNCT3 3'b111 
 
  `define CSR_PROC2MNGR 0x7C0
  `define CSR_MNGR2PROC 0xFC0
  `define CSR_COREID 0xF14
  `define CSR_NUMCORES 0xFC1
  `define CSR_STATS_EN 0x7C1 


  `define UNUSED_PARAM(x)  

  `define UNUSED_VAR(x) 

`define UNUSED_PIN(x)  


/** please update the following define with your own values */ 

 `define FE_latch_WIDTH  (1 + `INSTBITS+`DBITS+ `DBITS + `DBITS + 8 + `DBITS)
  `define DE_latch_WIDTH  (1 + `INSTBITS+`DBITS+`DBITS+ `IOPBITS + `DBITS + `DBITS + `DBITS + `DBITS + 1 + 1 + 1 + 1 + 1 + `REGNOBITS + 8 + `DBITS)

  `define AGEX_latch_WIDTH        (1 + `INSTBITS + `DBITS + `IOPBITS + `DBITS + `DBITS + `DBITS + 1 + 1 + `REGNOBITS + 1 + 8 + `DBITS)
  `define MEM_latch_WIDTH    (1 + `INSTBITS+`DBITS+ `IOPBITS + `DBITS + `DBITS + `DBITS + 1 + `REGNOBITS) 

  `define from_DE_to_FE_WIDTH  (1) 
  `define from_AGEX_to_FE_WIDTH (1 + `DBITS + 1 + 1 + `DBITS + `DBITS + 8)
  `define from_MEM_to_FE_WIDTH (1)
  `define from_WB_to_FE_WIDTH (1)

  `define from_AGEX_to_DE_WIDTH (1) 
  `define from_MEM_to_DE_WIDTH  (1)
  `define from_WB_to_DE_WIDTH  (1 + `REGNOBITS + `DBITS ) 

  `define from_MEM_to_AGEX_WIDTH  (1)
  `define from_WB_to_AGEX_WIDTH  (1)

  `define from_WB_to_MEM_WIDTH (1)



  
`endif 
```

```edit
./fe_stage.v
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
  input wire [`from_MEM_to_FE_WIDTH-1:0] from_MEM_to_FE,   
  input wire [`from_WB_to_FE_WIDTH-1:0] from_WB_to_FE, 
  output wire [`FE_latch_WIDTH-1:0] FE_latch_out
);

  `UNUSED_VAR (from_MEM_to_FE)
  `UNUSED_VAR (from_WB_to_FE)

  // I-MEM
  (* ram_init_file = `IDMEMINITFILE *)
  reg [`DBITS-1:0] imem [`IMEMWORDS-1:0];
 
  initial begin
      $readmemh(`IDMEMINITFILE , imem);
  end

  // G-share branch predictor
  reg [7:0] BHR;
  reg [1:0] PHT [255:0];
  
  // BTB
  reg valid_BTB [15:0];
  reg [25:0] tag_BTB [15:0];
  reg [31:0] target_BTB [15:0];

  /* pipeline latch */ 
  reg [`FE_latch_WIDTH-1:0] FE_latch;  // FE latch 
  wire valid_FE;
  assign valid_FE = 1'b1;
   
  `UNUSED_VAR(valid_FE)
  reg [`DBITS-1:0] PC_FE_latch; // PC latch in the FE stage   // you could use a part of FE_latch as a PC latch as well 
  
  reg [`DBITS-1:0] inst_count_FE; /* for debugging purpose */ 
  
  wire [`DBITS-1:0] inst_count_AGEX; /* for debugging purpose. resent the instruction counter */ 

  wire [`INSTBITS-1:0] inst_FE;  // instruction value in the FE stage 
  wire [`DBITS-1:0] pcplus_FE;  // pc plus value in the FE stage 
  wire stall_pipe_FE; // signal to indicate when a front-end needs to be stall
  
  wire [`FE_latch_WIDTH-1:0] FE_latch_contents;  // the signals that will be FE latch contents 
  
  // reading instruction from imem 
  assign inst_FE = imem[PC_FE_latch[`IMEMADDRBITS-1:`IMEMWORDBITS]];  // this code works. imem is stored 4B together 
  
  // wire to send the FE latch contents to the DE stage 
  assign FE_latch_out = FE_latch; 
 
  // This is the value of "incremented PC", computed in the FE stage
  assign pcplus_FE = PC_FE_latch + `INSTSIZE;
  
  // Prediction Logic
  wire [7:0] pht_idx_FE = PC_FE_latch[9:2] ^ BHR;
  wire [1:0] pht_counter_FE = PHT[pht_idx_FE];
  wire pht_predict_taken_FE = pht_counter_FE[1];
  
  wire [3:0] btb_idx_FE = PC_FE_latch[5:2];
  wire btb_hit_FE = valid_BTB[btb_idx_FE] && (tag_BTB[btb_idx_FE] == PC_FE_latch[31:6]);
  wire [31:0] btb_target_FE = target_BTB[btb_idx_FE];

  wire [31:0] next_pc_FE = (btb_hit_FE && pht_predict_taken_FE) ? btb_target_FE : pcplus_FE;
   
   // the order of latch contents should be matched in the decode stage when we extract the contents. 
  assign FE_latch_contents = {
                                valid_FE, 
                                inst_FE, 
                                PC_FE_latch, 
                                pcplus_FE, // please feel free to add more signals such as valid bits etc. 
                                inst_count_FE,
                                pht_idx_FE,
                                next_pc_FE
                                };

  wire br_mispred_AGEX;  
  wire [`DBITS-1:0] br_target_AGEX;  
  wire update_BP_AGEX;
  wire br_taken_AGEX;
  wire [`DBITS-1:0] br_target_calc_AGEX;
  wire [`DBITS-1:0] pc_AGEX;
  wire [7:0] pht_idx_AGEX;

  assign {
    stall_pipe_FE
  } = from_DE_to_FE[0]; 

  assign {
    br_mispred_AGEX,
    br_target_AGEX,
    update_BP_AGEX,
    br_taken_AGEX,
    br_target_calc_AGEX,
    pc_AGEX,
    pht_idx_AGEX
  } = from_AGEX_to_FE;

  integer i;
  always @ (posedge clk) begin
  /* you need to extend this always block */
   if (reset) begin 
      PC_FE_latch <= `STARTPC;
      inst_count_FE <= 1;  /* inst_count starts from 1 for easy human reading. 1st fetch instructions can have 1 */ 
      BHR <= 8'b0;
      for (i = 0; i < 256; i = i + 1) PHT[i] <= 2'b01;
      for (i = 0; i < 16; i = i + 1) begin
        valid_BTB[i] <= 1'b0;
        tag_BTB[i] <= 26'b0;
        target_BTB[i] <= 32'b0;
      end
    end 
    else if (br_mispred_AGEX)
      PC_FE_latch <= br_target_AGEX;
    else if (stall_pipe_FE) 
      PC_FE_latch <= PC_FE_latch; 
    else begin 
      PC_FE_latch <= next_pc_FE;
      inst_count_FE <= inst_count_FE + 1; 
    end 
    
    // Update predictor
    if (!reset && update_BP_AGEX) begin
        // Update BHR
        BHR <= {BHR[6:0], br_taken_AGEX};
        
        // Update PHT
        if (br_taken_AGEX) begin
            if (PHT[pht_idx_AGEX] < 2'b11) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] + 2'b01;
        end else begin
            if (PHT[pht_idx_AGEX] > 2'b00) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] - 2'b01;
        end
        
        // Update BTB
        valid_BTB[pc_AGEX[5:2]] <= 1'b1;
        tag_BTB[pc_AGEX[5:2]] <= pc_AGEX[31:6];
        target_BTB[pc_AGEX[5:2]] <= br_target_calc_AGEX;
    end
  end
  

  always @ (posedge clk) begin
    if (reset) begin 
      FE_latch <= '0; 
    end else begin 
      if (br_mispred_AGEX)
        FE_latch <= '0;
      else if (stall_pipe_FE)
        FE_latch <= FE_latch; 
      else 
        FE_latch <= FE_latch_contents; 
    end  
  end

endmodule
```

```edit
./de_stage.v
`include "define.vh" 


module DE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`FE_latch_WIDTH-1:0] from_FE_latch,
  input wire [`from_AGEX_to_DE_WIDTH-1:0] from_AGEX_to_DE,  
  input wire [`from_MEM_to_DE_WIDTH-1:0] from_MEM_to_DE,     
  input wire [`from_WB_to_DE_WIDTH-1:0] from_WB_to_DE,  
  output wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,   
  output wire [`DE_latch_WIDTH-1:0] DE_latch_out
);

  `UNUSED_VAR (from_MEM_to_DE)

  /* pipeline latch*/ 
  reg [`DE_latch_WIDTH-1:0] DE_latch; 


  /* architecture register file */ 
  reg [`DBITS-1:0] regs [`REGWORDS-1:0];

  
  /* decode signals */
  wire valid_DE;
  wire [`INSTBITS-1:0] inst_DE; 
  wire [`DBITS-1:0] PC_DE;
  wire [`DBITS-1:0] pcplus_DE; 
  wire [`DBITS-1:0] inst_count_DE; 
  wire [7:0] pht_idx_DE;
  wire [31:0] pred_pc_DE;
  wire[`DE_latch_WIDTH-1:0] DE_latch_contents; 

 

// extracting a part of opcode 
  wire [2:0] F3_DE; 
  wire [6:0] F7_DE; 
  wire [6:0] op_DE; 

  assign op_DE = inst_DE[6:0];  
  assign F3_DE = inst_DE[14:12];
  assign F7_DE = inst_DE[31:25];  
 
  /* opcode decoding logic */ 
  reg [`IOPBITS-1:0 ] op_I_DE; //  internal opcode enumerator for easy programming.  
  reg [`TYPENOBITS-1:0] type_I_DE;  // instruction format type information for decoding purpose 
  reg [`IMMTYPENOBITS-1:0] type_immediate_DE;  // immediate type information for decodding purpose 

  always @(*) begin 
    if ((op_DE == `ADD_OPCODE) && (F3_DE == `ADD_FUNCT3) && (F7_DE == `ADD_FUNCT7))
      op_I_DE = `ADD_I; 
    else if ((op_DE == `SUB_OPCODE) && (F3_DE == `SUB_FUNCT3) && (F7_DE == `SUB_FUNCT7))
      op_I_DE = `SUB_I; 
    else if ((op_DE == `AND_OPCODE) && (F3_DE == `AND_FUNCT3) && (F7_DE == `AND_FUNCT7))
      op_I_DE = `AND_I; 
    else if ((op_DE == `OR_OPCODE) && (F3_DE == `OR_FUNCT3) && (F7_DE == `OR_FUNCT7))
      op_I_DE = `OR_I; 
    else if ((op_DE == `XOR_OPCODE) && (F3_DE == `XOR_FUNCT3) && (F7_DE == `XOR_FUNCT7))
      op_I_DE = `XOR_I; 
    else if ((op_DE == `SLT_OPCODE) && (F3_DE == `SLT_FUNCT3) && (F7_DE == `SLT_FUNCT7))
      op_I_DE = `SLT_I; 
    else if ((op_DE == `SLTU_OPCODE) && (F3_DE == `SLTU_FUNCT3) && (F7_DE == `SLTU_FUNCT7))
      op_I_DE = `SLTU_I; 
    else if ((op_DE == `SRA_OPCODE) && (F3_DE == `SRA_FUNCT3) && (F7_DE == `SRA_FUNCT7))
      op_I_DE = `SRA_I; 
    else if ((op_DE == `SRL_OPCODE) && (F3_DE == `SRL_FUNCT3) && (F7_DE == `SRL_FUNCT7))
      op_I_DE = `SRL_I; 
    else if ((op_DE == `SLL_OPCODE) && (F3_DE == `SLL_FUNCT3) && (F7_DE == `SLL_FUNCT7))
      op_I_DE = `SLL_I; 
    else if ((op_DE == `MUL_OPCODE) && (F3_DE == `MUL_FUNCT3) && (F7_DE == `MUL_FUNCT7))
      op_I_DE = `MUL_I; 
    else if ((op_DE == `ADDI_OPCODE) && (F3_DE == `ADDI_FUNCT3))
      op_I_DE = `ADDI_I; 
    else if ((op_DE == `ANDI_OPCODE) && (F3_DE == `ANDI_FUNCT3))
      op_I_DE = `ANDI_I; 
    else if ((op_DE == `ORI_OPCODE) && (F3_DE == `ORI_FUNCT3))
      op_I_DE = `ORI_I; 
    else if ((op_DE == `XORI_OPCODE) && (F3_DE == `XORI_FUNCT3))
      op_I_DE = `XORI_I; 
    else if ((op_DE == `SLTI_OPCODE) && (F3_DE == `SLTI_FUNCT3))
      op_I_DE = `SLTI_I; 
    else if ((op_DE == `SLTIU_OPCODE) && (F3_DE == `SLTIU_FUNCT3))
      op_I_DE = `SLTIU_I; 
    else if ((op_DE == `SRAI_OPCODE) && (F3_DE == `SRAI_FUNCT3) && (F7_DE == `SRAI_FUNCT7))
      op_I_DE = `SRAI_I; 
    else if ((op_DE == `SRLI_OPCODE) && (F3_DE == `SRLI_FUNCT3) && (F7_DE == `SRLI_FUNCT7))
      op_I_DE = `SRLI_I; 
    else if ((op_DE == `SLLI_OPCODE) && (F3_DE == `SLLI_FUNCT3) && (F7_DE == `SLLI_FUNCT7))
      op_I_DE = `SLLI_I; 
    else if ((op_DE == `LUI_OPCODE))
      op_I_DE = `LUI_I; 
    else if ((op_DE == `AUIPC_OPCODE))
      op_I_DE = `AUIPC_I; 
    else if ((op_DE == `LW_OPCODE) && (F3_DE == `LW_FUNCT3))
      op_I_DE = `LW_I; 
    else if ((op_DE == `SW_OPCODE) && (F3_DE == `SW_FUNCT3))
      op_I_DE = `SW_I; 
    else if ((op_DE == `JAL_OPCODE))
      op_I_DE = `JAL_I; 
    else if ((op_DE == `JALR_OPCODE) && (F3_DE == `JALR_FUNCT3))
      op_I_DE = `JALR_I; 
    else if ((op_DE == `BEQ_OPCODE) && (F3_DE == `BEQ_FUNCT3))
      op_I_DE = `BEQ_I; 
    else if ((op_DE == `BNE_OPCODE) && (F3_DE == `BNE_FUNCT3))
      op_I_DE = `BNE_I; 
    else if ((op_DE == `BLT_OPCODE) && (F3_DE == `BLT_FUNCT3))
      op_I_DE = `BLT_I; 
    else if ((op_DE == `BGE_OPCODE) && (F3_DE == `BGE_FUNCT3))
      op_I_DE = `BGE_I; 
    else if ((op_DE == `BLTU_OPCODE) && (F3_DE == `BLTU_FUNCT3))
      op_I_DE = `BLTU_I; 
    else if ((op_DE == `BGEU_OPCODE) && (F3_DE == `BGEU_FUNCT3))
      op_I_DE = `BGEU_I; 
    else if ((op_DE == `CSRR_OPCODE) && (F3_DE == `CSRR_FUNCT3))
      op_I_DE = `CSRR_I; 
    else if ((op_DE == `CSRW_OPCODE) && (F3_DE == `CSRW_FUNCT3))
      op_I_DE = `CSRW_I; 
    else 
      op_I_DE = `INVALID_I; 
  end 

always @(*) begin
    type_I_DE = `TYPENOBITS'bx;
    type_immediate_DE = `IMMTYPENOBITS'bx;

    if ((op_I_DE == `ADD_I) || 
      (op_I_DE == `SUB_I ) || 
      (op_I_DE ==  `AND_I) || 
      (op_I_DE == `OR_I) || 
      (op_I_DE == `XOR_I) || 
      (op_I_DE == `SLT_I) || 
      (op_I_DE ==  `SLTU_I) || 
      (op_I_DE ==  `SRA_I) || 
      (op_I_DE == `SRL_I ) || 
      (op_I_DE == `SLL_I) || 
      (op_I_DE ==  `MUL_I) ) begin 
        type_I_DE = `R_Type;
      end

    else if ((op_I_DE == `CSRR_I) || 
      (op_I_DE == `CSRW_I) || 
      (op_I_DE == `ADDI_I ) || 
      (op_I_DE == `ANDI_I) || 
      (op_I_DE == `ORI_I) || 
      (op_I_DE == `XORI_I) || 
      (op_I_DE == `SLTI_I) ||  
      (op_I_DE == `SLTIU_I ) || 
      (op_I_DE == `LW_I ) || 
      (op_I_DE == `JR_I) || 
      (op_I_DE == `JALR_I) ) begin 
        type_I_DE = `I_Type; 
        type_immediate_DE = `I_immediate;
      end 

    else if ((op_I_DE ==  `SRAI_I ) || 
      (op_I_DE == `SRLI_I) || 
      (op_I_DE == `SLLI_I)) begin
        type_I_DE = `I_Type;
        type_immediate_DE = `I_immediate;
      end

    else if ((op_I_DE ==  `LUI_I) || 
      (op_I_DE == `AUIPC_I )) begin 
        type_I_DE = `I_Type; 
        type_immediate_DE = `U_immediate; 
      end

    else if (op_I_DE == `SW_I) begin
        type_I_DE = `S_Type;
        type_immediate_DE = `S_immediate;  
      end

    else if (op_I_DE ==  `JAL_I) begin 
        type_I_DE = `U_Type;
        type_immediate_DE = `J_immediate; 
      end

    else if ((op_I_DE ==  `BEQ_I ) || 
      (op_I_DE == `BNE_I) || 
      (op_I_DE == `BLT_I) || 
      (op_I_DE == `BGE_I) || 
      (op_I_DE == `BLTU_I) || 
      (op_I_DE == `BGEU_I)) begin 
        type_I_DE = `S_Type;
        type_immediate_DE = `B_immediate; 
      end

end
  


//////////////////////////////////
    // **TODO: Complete the rest of the pipeline 

   reg  [`DBITS-1:0] sxt_imm_DE;
always @(*) begin 
  case (type_immediate_DE )  
    `I_immediate: sxt_imm_DE = {{21{inst_DE[31]}}, inst_DE[30:25], inst_DE[24:21], inst_DE[20]}; 
    `S_immediate: sxt_imm_DE = {{21{inst_DE[31]}}, inst_DE[30:25], inst_DE[11:8], inst_DE[7]}; 
    `B_immediate: sxt_imm_DE = {{20{inst_DE[31]}}, inst_DE[7], inst_DE[30:25], inst_DE[11:8], 1'b0};
    `U_immediate: sxt_imm_DE = {inst_DE[31], inst_DE[30:20], inst_DE[19:12], 12'b0}; 
    `J_immediate: sxt_imm_DE = {{12{inst_DE[31]}}, inst_DE[19:12], inst_DE[20], inst_DE[30:25], inst_DE[24:21], 1'b0}; 
   default:
    sxt_imm_DE = 32'b0; 
  endcase  
end 
 

  wire [`REGNOBITS-1:0] rs1_DE;
  wire [`REGNOBITS-1:0] rs2_DE;
  wire [`REGNOBITS-1:0] rd_DE;
  
  wire [`DBITS-1:0] rs1_val_DE;
  wire [`DBITS-1:0] rs2_val_DE;

  wire is_br_DE;    // is conditional branch instr
  wire is_jmp_DE;   // is jump instr
  wire rd_mem_DE;   // is LD instr
  wire wr_mem_DE;   // is ST instr
  wire wr_reg_DE;   // is writing back to register file

  // Decode instruction registers
  assign rs1_DE = inst_DE[19:15];
  assign rs2_DE = inst_DE[24:20];
  assign rd_DE  = inst_DE[11:7]; 

  // Read register file
  assign rs1_val_DE = regs[rs1_DE];
  assign rs2_val_DE = regs[rs2_DE];


  assign is_br_DE  = ((op_I_DE == `BEQ_I) || (op_I_DE == `BNE_I) || (op_I_DE == `BLT_I) || (op_I_DE == `BGE_I) || (op_I_DE == `BLTU_I) || (op_I_DE == `BGEU_I)) ? 1 : 0;
  assign is_jmp_DE = ((op_I_DE == `JAL_I) || (op_I_DE == `JR_I) || (op_I_DE == `JALR_I)) ? 1 : 0;  
  assign rd_mem_DE = (op_I_DE == `LW_I) ? 1 :0 ;
  assign wr_mem_DE = (op_I_DE == `SW_I) ? 1 : 0 ; 
  assign wr_reg_DE = ((op_I_DE == `CSRR_I) || 
                      (op_I_DE == `ADD_I) || 
                      (op_I_DE == `SUB_I) || 
                      (op_I_DE == `AND_I) || 
                      (op_I_DE == `OR_I) || 
                      (op_I_DE == `XOR_I) || 
                      (op_I_DE == `SLT_I) || 
                      (op_I_DE == `SLTU_I) || 
                      (op_I_DE == `SRA_I) || 
                      (op_I_DE == `SRL_I) || 
                      (op_I_DE == `SLL_I) || 
                      (op_I_DE == `MUL_I) || 
                      (op_I_DE == `ADDI_I) || 
                      (op_I_DE == `ANDI_I) || 
                      (op_I_DE == `ORI_I) || 
                      (op_I_DE == `XORI_I) || 
                      (op_I_DE == `SLTI_I) || 
                      (op_I_DE == `SLTIU_I) || 
                      (op_I_DE == `SRAI_I) || 
                      (op_I_DE == `SRLI_I) || 
                      (op_I_DE == `SLLI_I) || 
                      (op_I_DE == `LUI_I) || 
                      (op_I_DE == `AUIPC_I) || 
                      (op_I_DE == `LW_I) || 
                      (op_I_DE == `JAL_I) || 
                      (op_I_DE == `JALR_I)) ? ((rd_DE != 0) ? 1 : 0): 0; 

 /* this signal is passed from WB stage */ 
  wire wr_reg_WB; // is this instruction writing into a register file? 
  wire [`REGNOBITS-1:0] wregno_WB; // destination register ID 
  wire [`DBITS-1:0] regval_WB;  // the contents to be written in the register file (or CSR )


  // signals come from WB stage for register WB 
  assign { wr_reg_WB, wregno_WB, regval_WB} = from_WB_to_DE;  


  wire pipeline_stall_DE; 
  assign from_DE_to_FE = {pipeline_stall_DE}; // pass the DE stage stall signal to FE stage 

  reg use_rs1_DE;
  reg use_rs2_DE;
  
  always @(*) begin 
    case (type_I_DE) 
    `I_Type: begin
      use_rs1_DE = 1;
      use_rs2_DE = 0; 
    end
    `R_Type: begin
      use_rs1_DE = 1;
      use_rs2_DE = 1; 
    end
    `S_Type: begin 
      use_rs1_DE = 1; 
      use_rs2_DE = 1; 
    end
    `U_Type: begin 
      use_rs1_DE = 0; 
      use_rs2_DE = 0;
    end
    default: begin
      use_rs1_DE = 0; 
      use_rs2_DE = 0;
    end
    endcase
  end
  
  // Handle data dependency

  reg [31:0] in_use_regs;
  wire has_data_hazards;
  wire br_mispred_AGEX;

  // process AGEX forwarding
  assign { 
    br_mispred_AGEX          
  } = from_AGEX_to_DE;

  assign has_data_hazards = (use_rs1_DE && in_use_regs[rs1_DE]) 
                         || (use_rs2_DE && in_use_regs[rs2_DE]);

  assign pipeline_stall_DE = has_data_hazards || br_mispred_AGEX;


  always @(posedge clk) begin
    if (reset) begin
      in_use_regs <= '0;
    end else begin
      if (~pipeline_stall_DE && wr_reg_DE) begin
        in_use_regs[rd_DE] <= 1;
      end 
      if (wr_reg_WB) begin
        in_use_regs[wregno_WB] <= 0;
      end
    end
  end

// decoding the contents of FE latch out. the order should be matched with the fe_stage.v 
  assign {
            valid_DE,
            inst_DE,
            PC_DE, 
            pcplus_DE,
            inst_count_DE,
            pht_idx_DE,
            pred_pc_DE
            }  = from_FE_latch;  // based on the contents of the latch, you can decode the content 


// assign wire to send the contents of DE latch to other pipeline stages  
  assign DE_latch_out = DE_latch; 

   assign DE_latch_contents = {
                                  valid_DE, 
                                  inst_DE,
                                  PC_DE,
                                  pcplus_DE,
                                  op_I_DE,
                                  inst_count_DE,
                                  // more signals might need
                                  rs1_val_DE,
                                  rs2_val_DE,    
                                  sxt_imm_DE,
                                  is_br_DE,
                                  is_jmp_DE,
                                  rd_mem_DE,
                                  wr_mem_DE,
                                  wr_reg_DE,
                                  rd_DE,
                                  pht_idx_DE,
                                  pred_pc_DE
                                  }; 





  always @ (negedge clk) begin 
  /* register write code is completed for your benefit */ 
    if(reset) begin 
      regs[0] <= {`DBITS{1'b0}};
      regs[1] <= {`DBITS{1'b0}};
      regs[2] <= {`DBITS{1'b0}};
      regs[3] <= {`DBITS{1'b0}};
      regs[4] <= {`DBITS{1'b0}};
      regs[5] <= {`DBITS{1'b0}};
      regs[6] <= {`DBITS{1'b0}};
      regs[7] <= {`DBITS{1'b0}};
      regs[8] <= {`DBITS{1'b0}};
      regs[9] <= {`DBITS{1'b0}};
      regs[10] <= {`DBITS{1'b0}};
      regs[11] <= {`DBITS{1'b0}};
      regs[12] <= {`DBITS{1'b0}};
      regs[13] <= {`DBITS{1'b0}};
      regs[14] <= {`DBITS{1'b0}};
      regs[15] <= {`DBITS{1'b0}};
      regs[16] <= {`DBITS{1'b0}};
      regs[17] <= {`DBITS{1'b0}};
      regs[18] <= {`DBITS{1'b0}};
      regs[19] <= {`DBITS{1'b0}};
      regs[20] <= {`DBITS{1'b0}};
      regs[21] <= {`DBITS{1'b0}};
      regs[22] <= {`DBITS{1'b0}};
      regs[23] <= {`DBITS{1'b0}};
      regs[24] <= {`DBITS{1'b0}};
      regs[25] <= {`DBITS{1'b0}};
      regs[26] <= {`DBITS{1'b0}};
      regs[27] <= {`DBITS{1'b0}};
      regs[28] <= {`DBITS{1'b0}};
      regs[29] <= {`DBITS{1'b0}};
      regs[30] <= {`DBITS{1'b0}};
      regs[31] <= {`DBITS{1'b0}};
    end
    else if(wr_reg_WB) 
		  	regs[wregno_WB] <= regval_WB; 
  end


always @ (posedge clk) begin // you need to expand this always block 
    if(reset) begin
      DE_latch <= {`DE_latch_WIDTH{1'b0}};
      end
     else begin  
      if (pipeline_stall_DE) 
        DE_latch <= {`DE_latch_WIDTH{1'b0}};
      else
          DE_latch <= DE_latch_contents;
     end 
  end



endmodule
```

```edit
./agex_stage.v
`include "define.vh" 

module AGEX_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_MEM_to_AGEX_WIDTH-1:0] from_MEM_to_AGEX,    
  input wire [`from_WB_to_AGEX_WIDTH-1:0] from_WB_to_AGEX,   
  input wire [`DE_latch_WIDTH-1:0] from_DE_latch,
  output wire [`AGEX_latch_WIDTH-1:0] AGEX_latch_out,
  output wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,
  output wire [`from_AGEX_to_DE_WIDTH-1:0] from_AGEX_to_DE
);

  `UNUSED_VAR (from_MEM_to_AGEX)
  `UNUSED_VAR (from_WB_to_AGEX)

  reg [`AGEX_latch_WIDTH-1:0] AGEX_latch; 
  // wire to send the AGEX latch contents to other pipeline stages 
  assign AGEX_latch_out = AGEX_latch;
  
  wire[`AGEX_latch_WIDTH-1:0] AGEX_latch_contents; 
  
  wire valid_AGEX; 
  wire [`INSTBITS-1:0]inst_AGEX; 
  wire [`DBITS-1:0]PC_AGEX;
  wire [`DBITS-1:0] inst_count_AGEX; 
  wire [`DBITS-1:0] pcplus_AGEX; 
  wire [`IOPBITS-1:0] op_I_AGEX;
  reg br_cond_AGEX; // 1 means a branch condition is satisified. 0 means a branch condition is not satisifed
 
  /////////////////////////////////////////////////////////////////////////////
  // TODO: Complete remaining code logic here!

  wire is_br_AGEX;
  wire is_jmp_AGEX;
  wire rd_mem_AGEX;
  wire wr_mem_AGEX;
  wire wr_reg_AGEX;
  wire [`REGNOBITS-1:0] wregno_AGEX;

  wire [`DBITS-1:0] regval1_AGEX;
  wire [`DBITS-1:0] regval2_AGEX;
  wire [`DBITS-1:0] sxt_imm_AGEX;
  
  wire [7:0] pht_idx_AGEX;
  wire [31:0] pred_pc_AGEX;

  reg [`DBITS-1:0] aluout_AGEX;
  reg [`DBITS-1:0] memaddr_AGEX;
  reg [`DBITS-1:0] br_target_AGEX;
  wire br_mispred_AGEX;

  
  // Calculate branch condition
  // TODO: complete the code
  always @ (*) begin
    case (op_I_AGEX)
    `BEQ_I : br_cond_AGEX = (regval1_AGEX == regval2_AGEX);
    `BNE_I : br_cond_AGEX = (regval1_AGEX != regval2_AGEX);
    `BLT_I : br_cond_AGEX = ($signed(regval1_AGEX) < $signed(regval2_AGEX));
    `BGE_I : br_cond_AGEX = ($signed(regval1_AGEX) >= $signed(regval2_AGEX));
    `BLTU_I: br_cond_AGEX = (regval1_AGEX < regval2_AGEX);
    `BGEU_I: br_cond_AGEX = (regval1_AGEX >= regval2_AGEX);
    default: br_cond_AGEX = 1'b0;
    endcase
  end

  // Compute ALU operations  (alu out or memory addresses)
  // TODO: complete the code
  always @ (*) begin
    case (op_I_AGEX)
    `ADD_I:   aluout_AGEX = regval1_AGEX + regval2_AGEX; 
    `SUB_I:   aluout_AGEX = regval1_AGEX - regval2_AGEX; 
    `AND_I:   aluout_AGEX = regval1_AGEX & regval2_AGEX; 
    `OR_I:    aluout_AGEX = regval1_AGEX | regval2_AGEX; 
    `XOR_I:   aluout_AGEX = regval1_AGEX ^ regval2_AGEX; 
    `SLT_I:   aluout_AGEX = ($signed(regval1_AGEX) < $signed(regval2_AGEX)) ? 1 : 0; 
    `SLTU_I:  aluout_AGEX = (regval1_AGEX < regval2_AGEX) ? 1 : 0;
    `SRA_I:   aluout_AGEX = $signed(regval1_AGEX) >>> $signed(regval2_AGEX[4:0]); 
    `SRL_I:   aluout_AGEX = regval1_AGEX >> regval2_AGEX[4:0]; 
    `SLL_I:   aluout_AGEX = regval1_AGEX << regval2_AGEX[4:0]; 
    `MUL_I:   aluout_AGEX = $signed(regval1_AGEX) * $signed(regval2_AGEX);
    `ADDI_I:  aluout_AGEX = regval1_AGEX + sxt_imm_AGEX; 
    `ANDI_I:  aluout_AGEX = regval1_AGEX & sxt_imm_AGEX; 
    `ORI_I:   aluout_AGEX = regval1_AGEX | sxt_imm_AGEX; 
    `XORI_I:  aluout_AGEX = regval1_AGEX ^ sxt_imm_AGEX;
    `SLTI_I:  aluout_AGEX = ($signed(regval1_AGEX) < $signed(sxt_imm_AGEX)) ? 1 : 0; 
    `SLTIU_I: aluout_AGEX = (regval1_AGEX < sxt_imm_AGEX) ? 1 : 0;
    `SRAI_I:  aluout_AGEX = $signed(regval1_AGEX) >>> $signed(sxt_imm_AGEX[4:0]); 
    `SRLI_I:  aluout_AGEX = regval1_AGEX >> sxt_imm_AGEX[4:0];
    `SLLI_I:  aluout_AGEX = regval1_AGEX << sxt_imm_AGEX[4:0];
    `LUI_I:   aluout_AGEX = sxt_imm_AGEX; 
    `AUIPC_I: aluout_AGEX = PC_AGEX + sxt_imm_AGEX;
    `JAL_I,
    `JALR_I:  aluout_AGEX = pcplus_AGEX;
    `LW_I:    memaddr_AGEX = regval1_AGEX + sxt_imm_AGEX;
    `SW_I: begin 
      memaddr_AGEX = regval1_AGEX + sxt_imm_AGEX;
      aluout_AGEX = regval2_AGEX; 
    end
    default: begin 
      aluout_AGEX  = '0;
      memaddr_AGEX = '0;		  
    end
    endcase
  end 

  // branch target needs to be computed here 
  // computed branch target needs to send to other pipeline stages (br_target_AGEX)
  // TODO: complete the code
  wire [31:0] br_target_calc_AGEX = (op_I_AGEX == `JAL_I) ? PC_AGEX + sxt_imm_AGEX :
                                     (op_I_AGEX == `JR_I) ? regval1_AGEX :
                                     (op_I_AGEX == `JALR_I) ? (regval1_AGEX + sxt_imm_AGEX) & 32'hfffffffe :
                                     (is_br_AGEX && br_cond_AGEX) ? PC_AGEX + sxt_imm_AGEX : 
                                     pcplus_AGEX;

  always @(*)begin
    if (is_jmp_AGEX || (is_br_AGEX && br_cond_AGEX)) 
      br_target_AGEX  = br_target_calc_AGEX;
    else 
      br_target_AGEX = pcplus_AGEX;        
  end

  assign br_mispred_AGEX = (valid_AGEX && (is_br_AGEX || is_jmp_AGEX)) && (br_target_AGEX != pred_pc_AGEX);

  wire update_BP_AGEX = valid_AGEX && (is_br_AGEX || is_jmp_AGEX);
  wire br_taken_AGEX = is_jmp_AGEX || (is_br_AGEX && br_cond_AGEX);

    assign  {                     
                                  valid_AGEX,
                                  inst_AGEX,
                                  PC_AGEX,
                                  pcplus_AGEX,
                                  op_I_AGEX,
                                  inst_count_AGEX,
                                          // more signals might need
                                  regval1_AGEX,
                                  regval2_AGEX,
                                  sxt_imm_AGEX,                                
                                  is_br_AGEX,
                                  is_jmp_AGEX,
                                  rd_mem_AGEX,
                                  wr_mem_AGEX,
                                  wr_reg_AGEX,
                                  wregno_AGEX,
                                  pht_idx_AGEX,
                                  pred_pc_AGEX
                                  } = from_DE_latch; 
    
 
  assign AGEX_latch_contents = {
                                valid_AGEX,
                                inst_AGEX,
                                PC_AGEX,
                                op_I_AGEX,
                                inst_count_AGEX,
                                       // more signals might need
                                memaddr_AGEX, 
                                aluout_AGEX,
                                rd_mem_AGEX,
                                wr_mem_AGEX,
                                wr_reg_AGEX,
                                wregno_AGEX,
                                pht_idx_AGEX,
                                pred_pc_AGEX
                                 }; 
 
  always @ (posedge clk ) begin
    if(reset) begin
      AGEX_latch <= {`AGEX_latch_WIDTH{1'b0}};
        end 
    else 
        begin
            AGEX_latch <= AGEX_latch_contents ;
        end 
  end


  // forward signals to FE stage
  assign from_AGEX_to_FE = { 
    br_mispred_AGEX, 
    br_target_AGEX,
    update_BP_AGEX,
    br_taken_AGEX,
    br_target_calc_AGEX,
    PC_AGEX,
    pht_idx_AGEX
  };

  // forward signals to DE stage
  assign from_AGEX_to_DE = { 
    br_mispred_AGEX
  };

  reg [31:0] bp_correct_cnt /* verilator public */;
  reg [31:0] bp_total_cnt /* verilator public */;

  always @(posedge clk) begin
    if (reset) begin
        bp_correct_cnt <= 0;
        bp_total_cnt <= 0;
    end else if (valid_AGEX && (is_br_AGEX || is_jmp_AGEX)) begin
        bp_total_cnt <= bp_total_cnt + 1;
        if (!br_mispred_AGEX) begin
            bp_correct_cnt <= bp_correct_cnt + 1;
        end
    end
  end

endmodule
```

```edit
./sim_main.cpp
// DESCRIPTION:  simulation of pipeline 
//======================================================================
#include <iostream>

// Include common routines
#include <verilated.h>
// Include model header, generated from Verilating "pipeline.v"
#include "Vpipeline.h"
#include "Vpipeline__Syms.h"

#ifdef VCD_OUTPUT
#include <verilated_vcd_c.h>
#endif

#define RUN_CYCLES 100000

#define CLOCK_PERIOD 2

#define RESET_TIME  10

// Current simulation time (64-bit unsigned)
uint64_t timestamp = 0;

double sc_time_stamp() { 
  return timestamp;
}

int main(int argc, char** argv, char** env) {
    // turn off unused variable warnings
    if (0 && argc && argv && env) {}

    // Construct the Verilated model
    Vpipeline* dut = new Vpipeline();

#ifdef VCD_OUTPUT
    Verilated::traceEverOn(true);
    auto trace = new VerilatedVcdC();
    dut->trace(trace, 2999);
    trace->open("trace.vcd");
#endif

#ifdef DPRINTF
    uint64_t inst_count_WB = 0;
    uint64_t timestamp_WB = 0;
#endif

    dut->clk = 0;
    dut->reset = 0;

    while (timestamp < RUN_CYCLES) {      
        bool clk_transition = (timestamp % CLOCK_PERIOD) == 0;
        if (clk_transition) 
            dut->clk = !dut->clk; 

        if (timestamp > 1 && timestamp < RESET_TIME) {
            dut->reset = 1;  // Assert reset
        } else {
            dut->reset = 0;  // Deassert reset
        }
        
        // Evaluate model
        dut->eval();

    #ifdef DPRINTF 
        // Verilator allows to access verilator public data structure
        if (clk_transition && dut->clk) {
            bool valid_WB = (int)dut->pipeline->my_WB_stage->WB_counters[0] != 0;
            if (valid_WB)  { 
                std::cout << "[" << (int)(timestamp) << "] ";
                std::cout << " PC=0x"   << std::hex << (int)dut->pipeline->my_WB_stage->WB_counters[1];
                std::cout << " Inst=0x" << std::hex << (int)dut->pipeline->my_WB_stage->WB_counters[2];
                std::cout << " Op="     << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[3];
                int wr_reg_WB = (int)dut->pipeline->my_WB_stage->WB_counters[4];
                if (wr_reg_WB) {
                    std::cout << " wr_reg=" << std::dec << wr_reg_WB; 
                    std::cout << " wregno=" << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[5];
                    std::cout << " regval=" << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[6];
                }
                std::cout << std::endl; 
                
                ++inst_count_WB;
                timestamp_WB = timestamp - RESET_TIME;
            }
        end
        }

    #endif

    #ifdef VCD_OUTPUT
        trace->dump(timestamp);
    #endif
        ++timestamp;
    }

#ifdef DPRINTF
    std::cout << "Total instructions=" << std::dec << inst_count_WB << ", cycles=" << (timestamp_WB / 2) << ", IPC=" << ((inst_count_WB * 2.0f) / timestamp_WB) << std::endl; 
#endif

    uint32_t bp_correct = dut->pipeline->my_AGEX_stage->bp_correct_cnt;
    uint32_t bp_total = dut->pipeline->my_AGEX_stage->bp_total_cnt;
    double accuracy = 0.0;
    if (bp_total > 0) accuracy = 100.0 * (double)bp_correct / (double)bp_total;
    std::cout << "Accuracy=" << accuracy << "%" << std::endl;

    int exitcode = (int)dut->pipeline->my_WB_stage->last_WB_value[3];

    // Final model cleanup
    dut->final();

#ifdef VCD_OUTPUT
    trace->close();
    delete trace;
#endif

    // Destroy DUT
    delete dut;

    // TinyRV1 test Pass/Fail status
    if (1 == exitcode)
        std::cout<<"Passed!"<<std::endl;
    else
        std::cout<<"Failed. exitcode: "<<exitcode<<std::endl;

    // Fin
    exit(0);
}
```

```test
```
2026-02-19 23:11:28,692 INFO Read wb_stage.v (96 lines)
2026-02-19 23:11:28,693 INFO Result for 'read' (first 500 chars):
Contents of wb_stage.v (96 lines):
```
 `include "define.vh" 


module WB_STAGE(
  input wire clk,
  input wire reset,  
  input wire [`MEM_latch_WIDTH-1:0] from_MEM_latch,
  output wire [`from_WB_to_FE_WIDTH-1:0] from_WB_to_FE,
  output wire [`from_WB_to_DE_WIDTH-1:0] from_WB_to_DE,  
  output wire [`from_WB_to_AGEX_WIDTH-1:0] from_WB_to_AGEX,
  output wire [`from_WB_to_MEM_WIDTH-1:0] from_WB_to_MEM
);

  wire valid_WB; 
  wire [`IOPBITS-1:0] op_I_WB;
  wire [`INSTBITS-1:0] inst_WB; 
  wire [`D
2026-02-19 23:11:28,698 INFO Wrote define.vh (6098 bytes)
2026-02-19 23:11:28,698 INFO Result for 'edit' (first 500 chars):
Wrote define.vh (6098 bytes). First 8 lines:
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
2026-02-19 23:11:28,699 INFO Wrote fe_stage.v (4922 bytes)
2026-02-19 23:11:28,700 INFO Result for 'edit' (first 500 chars):
Wrote fe_stage.v (4922 bytes). First 8 lines:
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
2026-02-19 23:11:28,702 INFO Wrote de_stage.v (14111 bytes)
2026-02-19 23:11:28,702 INFO Result for 'edit' (first 500 chars):
Wrote de_stage.v (14111 bytes). First 8 lines:
`include "define.vh" 


module DE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`FE_latch_WIDTH-1:0] from_FE_latch,
  input wire [`from_AGEX_to_DE_WIDTH-1:0] from_AGEX_to_DE,  
2026-02-19 23:11:28,703 INFO Wrote agex_stage.v (7632 bytes)
2026-02-19 23:11:28,703 INFO Result for 'edit' (first 500 chars):
Wrote agex_stage.v (7632 bytes). First 8 lines:
`include "define.vh" 

module AGEX_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_MEM_to_AGEX_WIDTH-1:0] from_MEM_to_AGEX,    
  input wire [`from_WB_to_AGEX_WIDTH-1:0] from_WB_to_AGEX,   
  input wire [`DE_latch_WIDTH-1:0] from_DE_latch,
2026-02-19 23:11:28,705 INFO Wrote sim_main.cpp (3685 bytes)
2026-02-19 23:11:28,705 INFO Result for 'edit' (first 500 chars):
Wrote sim_main.cpp (3685 bytes). First 8 lines:
// DESCRIPTION:  simulation of pipeline 
//======================================================================
#include <iostream>

// Include common routines
#include <verilated.h>
// Include model header, generated from Verilating "pipeline.v"
#include "Vpipeline.h"
2026-02-19 23:11:28,705 INFO Running part4 tests ...
2026-02-19 23:11:28,854 INFO part4 summary:
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
0
Number of failed tests:
0

2026-02-19 23:11:28,854 INFO Running part2 tests ...
2026-02-19 23:11:29,546 INFO part2 summary:
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
0
Number of failed tests:
0

2026-02-19 23:11:29,546 INFO Result for 'test' (first 500 chars):
=== part4 tests ===
BUILD FAILED  Verilator reported errors (no tests ran):
rm: cannot remove 'part4_tests.log': No such file or directory
%Warning-WIDTHTRUNC: mem_stage.v:80:36: Operator ASSIGNW expects 175 bits on the Assign RHS, but Assign RHS's VARREF 'from_AGEX_latch' generates 215 bits.
                                      : ... note: In instance 'pipeline.my_MEM_stage'
   80 |                                  } = from_AGEX_latch;  
      |                                    ^
          
2026-02-19 23:11:29,546 INFO --- Iteration 2 ---
2026-02-19 23:11:29,547 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:12:25,704 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:12:25,707 INFO Model:
```read
./mem_stage.v
```

```edit
./define.vh
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
  `define STARTPC   32'h200
  `define WBCOUNTERS  8
  
  //Memory mapped IO
  `define ADDRLEDR  32'hFFFFF020
  `define ADDRKEY   32'hFFFFF080
  `define ADDRSW    32'hFFFFF090

  
// address space is m 0x00000000 to 0x000fffff
  // [NOTICE] please note that both imem and dmem use the SAME "IDMEMINITFILE".
  // you need to change this line to change which test file to read 
  `define IDMEMINITFILE "/home/zhifan/workspace/cs3220-23fall/lab2/test/towers/towers.mem"
  `define IMEMADDRBITS  16
  `define IMEMWORDBITS  2
  `define IMEMWORDS	  (1 << (`IMEMADDRBITS - `IMEMWORDBITS))
  `define DMEMADDRBITS  16
  `define DMEMWORDBITS  2
  `define DMEMWORDS	  (1 << (`DMEMADDRBITS - `DMEMWORDBITS))
   
  `define CSRNOBITS 4
  `define CSR_ID_BIT_MASK 12'hF // this should match with CSRNOBITS 
  `define CSRREGNUM (1 << (`CSRNOBITS))

// internal instruction opcode enumerator for easy programming 

  `define IOPBITS 6
  `define TYPENOBITS 4 
  `define IMMTYPENOBITS 3 

  `define ADD_I    1 
  `define SUB_I    2 
  `define AND_I    3
  `define OR_I     4 
  `define XOR_I    5
  `define SLT_I    6
  `define SLTU_I   7
  `define SRA_I    8
  `define SRL_I    9
  `define SLL_I    10
  `define MUL_I    11
  `define ADDI_I   12 
  `define ANDI_I   13
  `define ORI_I    14
  `define XORI_I   15
  `define SLTI_I   16
  `define SLTIU_I  17
  `define SRAI_I   18
  `define SRLI_I   19
  `define SLLI_I   20
  `define LUI_I    21
  `define AUIPC_I  22
  `define LW_I     23
  `define SW_I     24
  `define JAL_I    25
  `define JR_I     26
  `define JALR_I   27
  `define BEQ_I    28
  `define BNE_I    29
  `define BLT_I    30
  `define BGE_I    31
  `define BLTU_I   32
  `define BGEU_I   33
  `define CSRR_I  34
  `define CSRW_I  35
  `define CSR_I    36
  `define INVALID_I 37 

  `define R_Type 1 
  `define I_Type 2 
  `define S_Type 3 
  `define U_Type 4 
  `define I_I_type 5 
  `define S_I_Type 6
  `define B_I_Type 7
  `define U_I_Type 8
  `define J_I_Type 9 

  `define I_immediate 1 
  `define J_immediate 2
  `define U_immediate 3
  `define S_immediate 4 
  `define B_immediate 5  


  `define CSRR_OPCODE 7'b1110011 
  `define CSRR_FUNCT3 3'b010
  `define CSRW_OPCODE 7'b1110011 
  `define CSRW_FUNCT3 3'b001  

  `define ADD_OPCODE 7'b0110011
  `define ADD_FUNCT3 3'b000
  `define ADD_FUNCT7 7'b0000000 
  `define SUB_OPCODE 7'b0110011
  `define SUB_FUNCT3 3'b000
  `define SUB_FUNCT7 7'b0100000
  `define AND_OPCODE 7'b0110011
  `define AND_FUNCT3 3'b111
  `define AND_FUNCT7 7'b0000000 
  `define OR_OPCODE  7'b0110011
  `define OR_FUNCT3  3'b110
  `define OR_FUNCT7  7'b0000000 
  `define XOR_OPCODE 7'b0110011
  `define XOR_FUNCT3 3'b100
  `define XOR_FUNCT7 7'b0000000 
  `define SLT_OPCODE 7'b0110011
  `define SLT_FUNCT3 3'b010 
  `define SLT_FUNCT7 7'b0000000 
  `define SLTU_OPCODE 7'b0110011
  `define SLTU_FUNCT3 3'b011 
  `define SLTU_FUNCT7 7'b0000000 

  `define SRA_OPCODE 7'b0110011 
  `define SRA_FUNCT3 3'b101 
  `define SRA_FUNCT7 7'b0100000 
  `define SRL_OPCODE 7'b0110011 
  `define SRL_FUNCT3  3'b101
  `define SRL_FUNCT7  7'b0000000 
  `define SLL_OPCODE  7'b0110011 
  `define SLL_FUNCT3  3'b001
  `define SLL_FUNCT7  7'b0000000 
  `define MUL_OPCODE 7'b0110011 
  `define MUL_FUNCT3 3'b000 
  `define MUL_FUNCT7  7'b0000001   
  

  `define ADDI_OPCODE 7'b0010011   
  `define ADDI_FUNCT3 3'b000 
  `define ANDI_OPCODE 7'b0010011 
  `define ANDI_FUNCT3 3'b111
  `define ORI_OPCODE 7'b0010011 
  `define ORI_FUNCT3 3'b110 
  `define XORI_OPCODE 7'b0010011  
  `define XORI_FUNCT3 3'b100 
  `define SLTI_OPCODE 7'b0010011  
  `define SLTI_FUNCT3  3'b010 
  `define SLTIU_OPCODE 7'b0010011 
  `define SLTIU_FUNCT3  3'b011 

  `define SRAI_OPCODE  7'b0010011  
  `define SRAI_FUNCT3   3'b101 
  `define SRAI_FUNCT7  7'b0100000 
  `define SRLI_OPCODE  7'b0010011   
  `define SRLI_FUNCT3  3'b101 
  `define SRLI_FUNCT7  7'b0000000 

  `define SLLI_OPCODE 7'b0010011
  `define SLLI_FUNCT3  3'b001 
  `define SLLI_FUNCT7  7'b0000000   
  `define LUI_OPCODE 7'b0110111 

  `define AUIPC_OPCODE  7'b0010111  

  `define LW_OPCODE  7'b0000011 
  `define LW_FUNCT3  3'b010  
  `define SW_OPCODE 7'b0100011 
  `define SW_FUNCT3 3'b010 

  `define JAL_OPCODE 7'b1101111 
  `define JR_OPCODE  7'b1100111  
  `define JR_FUNCT3 3'b000
  `define JR_10MSB 10'b000000000000    
  `define JALR_OPCODE 7'b1100111    
  `define JALR_FUNCT3  3'b000 

  `define BEQ_OPCODE 7'b1100011  
  `define BEQ_FUNCT3 3'b000
  `define BNE_OPCODE 7'b1100011  
  `define BNE_FUNCT3 3'b001  

  `define BLT_OPCODE 7'b1100011 
  `define BLT_FUNCT3 3'b100
  `define BGE_OPCODE 7'b1100011  
  `define BGE_FUNCT3 3'b101 
  `define BLTU_OPCODE 7'b1100011
  `define BLTU_FUNCT3 3'b110
  `define BGEU_OPCODE 7'b1100011
  `define BGEU_FUNCT3 3'b111 
 
  `define CSR_PROC2MNGR 0x7C0
  `define CSR_MNGR2PROC 0xFC0
  `define CSR_COREID 0xF14
  `define CSR_NUMCORES 0xFC1
  `define CSR_STATS_EN 0x7C1 


  `define UNUSED_PARAM(x)  

  `define UNUSED_VAR(x) 

`define UNUSED_PIN(x)  


/** please update the following define with your own values */ 

 `define FE_latch_WIDTH  (1 + `INSTBITS+`DBITS+ `DBITS + `DBITS + 8 + `DBITS)
  `define DE_latch_WIDTH  (1 + `INSTBITS+`DBITS+`DBITS+ `IOPBITS + `DBITS + `DBITS + `DBITS + `DBITS + 1 + 1 + 1 + 1 + 1 + `REGNOBITS + 8 + `DBITS)

  `define AGEX_latch_WIDTH        (1 + `INSTBITS + `DBITS + `IOPBITS + `DBITS + `DBITS + `DBITS + 1 + 1 + `REGNOBITS)
  `define MEM_latch_WIDTH    (1 + `INSTBITS+`DBITS+ `IOPBITS + `DBITS + `DBITS + `DBITS + 1 + `REGNOBITS) 

  `define from_DE_to_FE_WIDTH  (1) 
  `define from_AGEX_to_FE_WIDTH (1 + `DBITS + 1 + 1 + `DBITS + `DBITS + 8)
  `define from_MEM_to_FE_WIDTH (1)
  `define from_WB_to_FE_WIDTH (1)

  `define from_AGEX_to_DE_WIDTH (1) 
  `define from_MEM_to_DE_WIDTH  (1)
  `define from_WB_to_DE_WIDTH  (1 + `REGNOBITS + `DBITS ) 

  `define from_MEM_to_AGEX_WIDTH  (1)
  `define from_WB_to_AGEX_WIDTH  (1)

  `define from_WB_to_MEM_WIDTH (1)



  
`endif 
```

```edit
./fe_stage.v
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
  input wire [`from_MEM_to_FE_WIDTH-1:0] from_MEM_to_FE,   
  input wire [`from_WB_to_FE_WIDTH-1:0] from_WB_to_FE, 
  output wire [`FE_latch_WIDTH-1:0] FE_latch_out
);

  `UNUSED_VAR (from_MEM_to_FE)
  `UNUSED_VAR (from_WB_to_FE)

  // I-MEM
  (* ram_init_file = `IDMEMINITFILE *)
  reg [`DBITS-1:0] imem [`IMEMWORDS-1:0];
 
  initial begin
      $readmemh(`IDMEMINITFILE , imem);
  end

  // G-share branch predictor
  reg [7:0] BHR;
  reg [1:0] PHT [255:0];
  
  // BTB
  reg valid_BTB [15:0];
  reg [25:0] tag_BTB [15:0];
  reg [31:0] target_BTB [15:0];

  /* pipeline latch */ 
  reg [`FE_latch_WIDTH-1:0] FE_latch;  // FE latch 
  wire valid_FE;
  assign valid_FE = 1'b1;
   
  `UNUSED_VAR(valid_FE)
  reg [`DBITS-1:0] PC_FE_latch; // PC latch in the FE stage   // you could use a part of FE_latch as a PC latch as well 
  
  reg [`DBITS-1:0] inst_count_FE; /* for debugging purpose */ 
  
  wire [`DBITS-1:0] inst_count_AGEX; /* for debugging purpose. resent the instruction counter */ 

  wire [`INSTBITS-1:0] inst_FE;  // instruction value in the FE stage 
  wire [`DBITS-1:0] pcplus_FE;  // pc plus value in the FE stage 
  wire stall_pipe_FE; // signal to indicate when a front-end needs to be stall
  
  wire [`FE_latch_WIDTH-1:0] FE_latch_contents;  // the signals that will be FE latch contents 
  
  // reading instruction from imem 
  assign inst_FE = imem[PC_FE_latch[`IMEMADDRBITS-1:`IMEMWORDBITS]];  // this code works. imem is stored 4B together 
  
  // wire to send the FE latch contents to the DE stage 
  assign FE_latch_out = FE_latch; 
 
  // This is the value of "incremented PC", computed in the FE stage
  assign pcplus_FE = PC_FE_latch + `INSTSIZE;
  
  // Prediction Logic
  wire [7:0] pht_idx_FE = PC_FE_latch[9:2] ^ BHR;
  wire [1:0] pht_counter_FE = PHT[pht_idx_FE];
  wire pht_predict_taken_FE = pht_counter_FE[1];
  
  wire [3:0] btb_idx_FE = PC_FE_latch[5:2];
  wire btb_hit_FE = valid_BTB[btb_idx_FE] && (tag_BTB[btb_idx_FE] == PC_FE_latch[31:6]);
  wire [31:0] btb_target_FE = target_BTB[btb_idx_FE];

  wire [31:0] next_pc_FE = (btb_hit_FE && pht_predict_taken_FE) ? btb_target_FE : pcplus_FE;
   
   // the order of latch contents should be matched in the decode stage when we extract the contents. 
  assign FE_latch_contents = {
                                valid_FE, 
                                inst_FE, 
                                PC_FE_latch, 
                                pcplus_FE, // please feel free to add more signals such as valid bits etc. 
                                inst_count_FE,
                                pht_idx_FE,
                                next_pc_FE
                                };

  wire br_mispred_AGEX;  
  wire [`DBITS-1:0] br_target_AGEX;  
  wire update_BP_AGEX;
  wire br_taken_AGEX;
  wire [`DBITS-1:0] br_target_calc_AGEX;
  wire [`DBITS-1:0] pc_AGEX;
  wire [7:0] pht_idx_AGEX;

  assign {
    br_mispred_AGEX,
    br_target_AGEX,
    update_BP_AGEX,
    br_taken_AGEX,
    br_target_calc_AGEX,
    pc_AGEX,
    pht_idx_AGEX
  } = from_AGEX_to_FE;

  assign {
    stall_pipe_FE
  } = from_DE_to_FE[0]; 

  integer i;
  always @ (posedge clk) begin
  /* you need to extend this always block */
   if (reset) begin 
      PC_FE_latch <= `STARTPC;
      inst_count_FE <= 1;  /* inst_count starts from 1 for easy human reading. 1st fetch instructions can have 1 */ 
      BHR <= 8'b0;
      for (i = 0; i < 256; i = i + 1) PHT[i] = 2'b01;
      for (i = 0; i < 16; i = i + 1) begin
        valid_BTB[i] = 1'b0;
        tag_BTB[i] = 26'b0;
        target_BTB[i] = 32'b0;
      end
    end 
    else if (br_mispred_AGEX)
      PC_FE_latch <= br_target_AGEX;
    else if (stall_pipe_FE) 
      PC_FE_latch <= PC_FE_latch; 
    else begin 
      PC_FE_latch <= next_pc_FE;
      inst_count_FE <= inst_count_FE + 1; 
    end 
    
    // Update predictor
    if (!reset && update_BP_AGEX) begin
        // Update BHR
        BHR <= {BHR[6:0], br_taken_AGEX};
        
        // Update PHT
        if (br_taken_AGEX) begin
            if (PHT[pht_idx_AGEX] < 2'b11) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] + 2'b01;
        end else begin
            if (PHT[pht_idx_AGEX] > 2'b00) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] - 2'b01;
        end
        
        // Update BTB
        valid_BTB[pc_AGEX[5:2]] <= 1'b1;
        tag_BTB[pc_AGEX[5:2]] <= pc_AGEX[31:6];
        target_BTB[pc_AGEX[5:2]] <= br_target_calc_AGEX;
    end
  end
  

  always @ (posedge clk) begin
    if (reset) begin 
      FE_latch <= '0; 
    end else begin 
      if (br_mispred_AGEX)
        FE_latch <= '0;
      else if (stall_pipe_FE)
        FE_latch <= FE_latch; 
      else 
        FE_latch <= FE_latch_contents; 
    end  
  end

endmodule
```

```edit
./agex_stage.v
`include "define.vh" 

module AGEX_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_MEM_to_AGEX_WIDTH-1:0] from_MEM_to_AGEX,    
  input wire [`from_WB_to_AGEX_WIDTH-1:0] from_WB_to_AGEX,   
  input wire [`DE_latch_WIDTH-1:0] from_DE_latch,
  output wire [`AGEX_latch_WIDTH-1:0] AGEX_latch_out,
  output wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,
  output wire [`from_AGEX_to_DE_WIDTH-1:0] from_AGEX_to_DE
);

  `UNUSED_VAR (from_MEM_to_AGEX)
  `UNUSED_VAR (from_WB_to_AGEX)

  reg [`AGEX_latch_WIDTH-1:0] AGEX_latch; 
  // wire to send the AGEX latch contents to other pipeline stages 
  assign AGEX_latch_out = AGEX_latch;
  
  wire[`AGEX_latch_WIDTH-1:0] AGEX_latch_contents; 
  
  wire valid_AGEX; 
  wire [`INSTBITS-1:0]inst_AGEX; 
  wire [`DBITS-1:0]PC_AGEX;
  wire [`DBITS-1:0] inst_count_AGEX; 
  wire [`DBITS-1:0] pcplus_AGEX; 
  wire [`IOPBITS-1:0] op_I_AGEX;
  reg br_cond_AGEX; // 1 means a branch condition is satisified. 0 means a branch condition is not satisifed
 
  /////////////////////////////////////////////////////////////////////////////
  // TODO: Complete remaining code logic here!

  wire is_br_AGEX;
  wire is_jmp_AGEX;
  wire rd_mem_AGEX;
  wire wr_mem_AGEX;
  wire wr_reg_AGEX;
  wire [`REGNOBITS-1:0] wregno_AGEX;

  wire [`DBITS-1:0] regval1_AGEX;
  wire [`DBITS-1:0] regval2_AGEX;
  wire [`DBITS-1:0] sxt_imm_AGEX;
  
  wire [7:0] pht_idx_AGEX;
  wire [31:0] pred_pc_AGEX;

  reg [`DBITS-1:0] aluout_AGEX;
  reg [`DBITS-1:0] memaddr_AGEX;
  reg [`DBITS-1:0] br_target_AGEX;
  wire br_mispred_AGEX;

  
  // Calculate branch condition
  // TODO: complete the code
  always @ (*) begin
    case (op_I_AGEX)
    `BEQ_I : br_cond_AGEX = (regval1_AGEX == regval2_AGEX);
    `BNE_I : br_cond_AGEX = (regval1_AGEX != regval2_AGEX);
    `BLT_I : br_cond_AGEX = ($signed(regval1_AGEX) < $signed(regval2_AGEX));
    `BGE_I : br_cond_AGEX = ($signed(regval1_AGEX) >= $signed(regval2_AGEX));
    `BLTU_I: br_cond_AGEX = (regval1_AGEX < regval2_AGEX);
    `BGEU_I: br_cond_AGEX = (regval1_AGEX >= regval2_AGEX);
    default: br_cond_AGEX = 1'b0;
    endcase
  end

  // Compute ALU operations  (alu out or memory addresses)
  // TODO: complete the code
  always @ (*) begin
    case (op_I_AGEX)
    `ADD_I:   aluout_AGEX = regval1_AGEX + regval2_AGEX; 
    `SUB_I:   aluout_AGEX = regval1_AGEX - regval2_AGEX; 
    `AND_I:   aluout_AGEX = regval1_AGEX & regval2_AGEX; 
    `OR_I:    aluout_AGEX = regval1_AGEX | regval2_AGEX; 
    `XOR_I:   aluout_AGEX = regval1_AGEX ^ regval2_AGEX; 
    `SLT_I:   aluout_AGEX = ($signed(regval1_AGEX) < $signed(regval2_AGEX)) ? 1 : 0; 
    `SLTU_I:  aluout_AGEX = (regval1_AGEX < regval2_AGEX) ? 1 : 0;
    `SRA_I:   aluout_AGEX = $signed(regval1_AGEX) >>> $signed(regval2_AGEX[4:0]); 
    `SRL_I:   aluout_AGEX = regval1_AGEX >> regval2_AGEX[4:0]; 
    `SLL_I:   aluout_AGEX = regval1_AGEX << regval2_AGEX[4:0]; 
    `MUL_I:   aluout_AGEX = $signed(regval1_AGEX) * $signed(regval2_AGEX);
    `ADDI_I:  aluout_AGEX = regval1_AGEX + sxt_imm_AGEX; 
    `ANDI_I:  aluout_AGEX = regval1_AGEX & sxt_imm_AGEX; 
    `ORI_I:   aluout_AGEX = regval1_AGEX | sxt_imm_AGEX; 
    `XORI_I:  aluout_AGEX = regval1_AGEX ^ sxt_imm_AGEX;
    `SLTI_I:  aluout_AGEX = ($signed(regval1_AGEX) < $signed(sxt_imm_AGEX)) ? 1 : 0; 
    `SLTIU_I: aluout_AGEX = (regval1_AGEX < sxt_imm_AGEX) ? 1 : 0;
    `SRAI_I:  aluout_AGEX = $signed(regval1_AGEX) >>> $signed(sxt_imm_AGEX[4:0]); 
    `SRLI_I:  aluout_AGEX = regval1_AGEX >> sxt_imm_AGEX[4:0];
    `SLLI_I:  aluout_AGEX = regval1_AGEX << sxt_imm_AGEX[4:0];
    `LUI_I:   aluout_AGEX = sxt_imm_AGEX; 
    `AUIPC_I: aluout_AGEX = PC_AGEX + sxt_imm_AGEX;
    `JAL_I,
    `JALR_I:  aluout_AGEX = pcplus_AGEX;
    `LW_I:    memaddr_AGEX = regval1_AGEX + sxt_imm_AGEX;
    `SW_I: begin 
      memaddr_AGEX = regval1_AGEX + sxt_imm_AGEX;
      aluout_AGEX = regval2_AGEX; 
    end
    default: begin 
      aluout_AGEX  = '0;
      memaddr_AGEX = '0;		  
    end
    endcase
  end 

  // branch target needs to be computed here 
  // computed branch target needs to send to other pipeline stages (br_target_AGEX)
  // TODO: complete the code
  wire [31:0] br_target_calc_AGEX = (op_I_AGEX == `JAL_I) ? PC_AGEX + sxt_imm_AGEX :
                                     (op_I_AGEX == `JR_I) ? regval1_AGEX :
                                     (op_I_AGEX == `JALR_I) ? (regval1_AGEX + sxt_imm_AGEX) & 32'hfffffffe :
                                     (is_br_AGEX && br_cond_AGEX) ? PC_AGEX + sxt_imm_AGEX : 
                                     pcplus_AGEX;

  always @(*)begin
    if (is_jmp_AGEX || (is_br_AGEX && br_cond_AGEX)) 
      br_target_AGEX  = br_target_calc_AGEX;
    else 
      br_target_AGEX = pcplus_AGEX;        
  end

  assign br_mispred_AGEX = (valid_AGEX && (is_br_AGEX || is_jmp_AGEX)) && (br_target_AGEX != pred_pc_AGEX);

  wire update_BP_AGEX = valid_AGEX && (is_br_AGEX || is_jmp_AGEX);
  wire br_taken_AGEX = is_jmp_AGEX || (is_br_AGEX && br_cond_AGEX);

    assign  {                     
                                  valid_AGEX,
                                  inst_AGEX,
                                  PC_AGEX,
                                  pcplus_AGEX,
                                  op_I_AGEX,
                                  inst_count_AGEX,
                                          // more signals might need
                                  regval1_AGEX,
                                  regval2_AGEX,
                                  sxt_imm_AGEX,                                
                                  is_br_AGEX,
                                  is_jmp_AGEX,
                                  rd_mem_AGEX,
                                  wr_mem_AGEX,
                                  wr_reg_AGEX,
                                  wregno_AGEX,
                                  pht_idx_AGEX,
                                  pred_pc_AGEX
                                  } = from_DE_latch; 
    
 
  assign AGEX_latch_contents = {
                                valid_AGEX,
                                inst_AGEX,
                                PC_AGEX,
                                op_I_AGEX,
                                inst_count_AGEX,
                                       // more signals might need
                                memaddr_AGEX, 
                                aluout_AGEX,
                                rd_mem_AGEX,
                                wr_mem_AGEX,
                                wr_reg_AGEX,
                                wregno_AGEX
                                 }; 
 
  always @ (posedge clk ) begin
    if(reset) begin
      AGEX_latch <= {`AGEX_latch_WIDTH{1'b0}};
        end 
    else 
        begin
            AGEX_latch <= AGEX_latch_contents ;
        end 
  end


  // forward signals to FE stage
  assign from_AGEX_to_FE = { 
    br_mispred_AGEX, 
    br_target_AGEX,
    update_BP_AGEX,
    br_taken_AGEX,
    br_target_calc_AGEX,
    PC_AGEX,
    pht_idx_AGEX
  };

  // forward signals to DE stage
  assign from_AGEX_to_DE = { 
    br_mispred_AGEX
  };

  reg [31:0] bp_correct_cnt /* verilator public */;
  reg [31:0] bp_total_cnt /* verilator public */;

  always @(posedge clk) begin
    if (reset) begin
        bp_correct_cnt <= 0;
        bp_total_cnt <= 0;
    end else if (valid_AGEX && (is_br_AGEX || is_jmp_AGEX)) begin
        bp_total_cnt <= bp_total_cnt + 1;
        if (!br_mispred_AGEX) begin
            bp_correct_cnt <= bp_correct_cnt + 1;
        end
    end
  end

endmodule
```

```edit
./sim_main.cpp
// DESCRIPTION:  simulation of pipeline 
//======================================================================
#include <iostream>

// Include common routines
#include <verilated.h>
// Include model header, generated from Verilating "pipeline.v"
#include "Vpipeline.h"
#include "Vpipeline__Syms.h"

#ifdef VCD_OUTPUT
#include <verilated_vcd_c.h>
#endif

#define RUN_CYCLES 100000

#define CLOCK_PERIOD 2

#define RESET_TIME  10

// Current simulation time (64-bit unsigned)
uint64_t timestamp = 0;

double sc_time_stamp() { 
  return timestamp;
}

int main(int argc, char** argv, char** env) {
    // turn off unused variable warnings
    if (0 && argc && argv && env) {}

    // Construct the Verilated model
    Vpipeline* dut = new Vpipeline();

#ifdef VCD_OUTPUT
    Verilated::traceEverOn(true);
    auto trace = new VerilatedVcdC();
    dut->trace(trace, 2999);
    trace->open("trace.vcd");
#endif

#ifdef DPRINTF
    uint64_t inst_count_WB = 0;
    uint64_t timestamp_WB = 0;
#endif

    dut->clk = 0;
    dut->reset = 0;

    while (timestamp < RUN_CYCLES) {      
        bool clk_transition = (timestamp % CLOCK_PERIOD) == 0;
        if (clk_transition) 
            dut->clk = !dut->clk; 

        if (timestamp > 1 && timestamp < RESET_TIME) {
            dut->reset = 1;  // Assert reset
        } else {
            dut->reset = 0;  // Deassert reset
        }
        
        // Evaluate model
        dut->eval();

    #ifdef DPRINTF 
        // Verilator allows to access verilator public data structure
        if (clk_transition && dut->clk) {
            bool valid_WB = (int)dut->pipeline->my_WB_stage->WB_counters[0] != 0;
            if (valid_WB)  { 
                std::cout << "[" << (int)(timestamp) << "] ";
                std::cout << " PC=0x"   << std::hex << (int)dut->pipeline->my_WB_stage->WB_counters[1];
                std::cout << " Inst=0x" << std::hex << (int)dut->pipeline->my_WB_stage->WB_counters[2];
                std::cout << " Op="     << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[3];
                int wr_reg_WB = (int)dut->pipeline->my_WB_stage->WB_counters[4];
                if (wr_reg_WB) {
                    std::cout << " wr_reg=" << std::dec << wr_reg_WB; 
                    std::cout << " wregno=" << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[5];
                    std::cout << " regval=" << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[6];
                }
                std::cout << std::endl; 
                
                ++inst_count_WB;
                timestamp_WB = timestamp - RESET_TIME;
            }
        }

    #endif

    #ifdef VCD_OUTPUT
        trace->dump(timestamp);
    #endif
        ++timestamp;
    }

#ifdef DPRINTF
    std::cout << "Total instructions=" << std::dec << inst_count_WB << ", cycles=" << (timestamp_WB / 2) << ", IPC=" << ((inst_count_WB * 2.0f) / timestamp_WB) << std::endl; 
#endif

    uint32_t bp_correct = dut->pipeline->my_AGEX_stage->bp_correct_cnt;
    uint32_t bp_total = dut->pipeline->my_AGEX_stage->bp_total_cnt;
    double accuracy = 0.0;
    if (bp_total > 0) accuracy = 100.0 * (double)bp_correct / (double)bp_total;
    std::cout << "Accuracy=" << accuracy << "%" << std::endl;

    int exitcode = (int)dut->pipeline->my_WB_stage->last_WB_value[3];

    // Final model cleanup
    dut->final();

#ifdef VCD_OUTPUT
    trace->close();
    delete trace;
#endif

    // Destroy DUT
    delete dut;

    // TinyRV1 test Pass/Fail status
    if (1 == exitcode)
        std::cout<<"Passed!"<<std::endl;
    else
        std::cout<<"Failed. exitcode: "<<exitcode<<std::endl;

    // Fin
    exit(0);
}
```

```test
```
2026-02-19 23:12:25,709 INFO Read mem_stage.v (118 lines)
2026-02-19 23:12:25,709 INFO Result for 'read' (first 500 chars):
Contents of mem_stage.v (118 lines):
```
 `include "define.vh" 

module MEM_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_WB_to_MEM_WIDTH-1:0] from_WB_to_MEM,  
  input wire [`AGEX_latch_WIDTH-1:0] from_AGEX_latch, 
  output wire [`MEM_latch_WIDTH-1:0] MEM_latch_out,
  output wire [`from_MEM_to_FE_WIDTH-1:0] from_MEM_to_FE,
  output wire [`from_MEM_to_DE_WIDTH-1:0] from_MEM_to_DE,
  output wire [`from_WB_to_AGEX_WIDTH-1:0] from_MEM_to_AGEX
);

  `UNUSED_VAR (from_WB_to_MEM)
  
2026-02-19 23:12:25,711 INFO Wrote define.vh (6081 bytes)
2026-02-19 23:12:25,712 INFO Result for 'edit' (first 500 chars):
Wrote define.vh (6081 bytes). First 8 lines:
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
2026-02-19 23:12:25,713 INFO Wrote fe_stage.v (4918 bytes)
2026-02-19 23:12:25,713 INFO Result for 'edit' (first 500 chars):
Wrote fe_stage.v (4918 bytes). First 8 lines:
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
2026-02-19 23:12:25,714 INFO Wrote agex_stage.v (7540 bytes)
2026-02-19 23:12:25,714 INFO Result for 'edit' (first 500 chars):
Wrote agex_stage.v (7540 bytes). First 8 lines:
`include "define.vh" 

module AGEX_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_MEM_to_AGEX_WIDTH-1:0] from_MEM_to_AGEX,    
  input wire [`from_WB_to_AGEX_WIDTH-1:0] from_WB_to_AGEX,   
  input wire [`DE_latch_WIDTH-1:0] from_DE_latch,
2026-02-19 23:12:25,714 INFO Wrote sim_main.cpp (3673 bytes)
2026-02-19 23:12:25,715 INFO Result for 'edit' (first 500 chars):
Wrote sim_main.cpp (3673 bytes). First 8 lines:
// DESCRIPTION:  simulation of pipeline 
//======================================================================
#include <iostream>

// Include common routines
#include <verilated.h>
// Include model header, generated from Verilating "pipeline.v"
#include "Vpipeline.h"
2026-02-19 23:12:25,715 INFO Running part4 tests ...
2026-02-19 23:12:25,814 INFO part4 summary:
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
0
Number of failed tests:
0

2026-02-19 23:12:25,815 INFO Running part2 tests ...
2026-02-19 23:12:26,706 INFO part2 summary:
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
0
Number of failed tests:
0

2026-02-19 23:12:26,706 INFO Result for 'test' (first 500 chars):
=== part4 tests ===
BUILD FAILED  Verilator reported errors (no tests ran):
%Warning-WIDTHTRUNC: agex_stage.v:151:30: Operator ASSIGNW expects 174 bits on the Assign RHS, but Assign RHS's REPLICATE generates 175 bits.
                                        : ... note: In instance 'pipeline.my_AGEX_stage'
  151 |   assign AGEX_latch_contents = {
      |                              ^
                     ... For warning description see https://verilator.org/warn/WIDTHTRUNC?v=5.020
             
2026-02-19 23:12:26,706 INFO --- Iteration 3 ---
2026-02-19 23:12:26,706 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:13:37,340 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:13:37,345 INFO Model:
```edit
./define.vh
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
  `define STARTPC   32'h200
  `define WBCOUNTERS  8
  
  //Memory mapped IO
  `define ADDRLEDR  32'hFFFFF020
  `define ADDRKEY   32'hFFFFF080
  `define ADDRSW    32'hFFFFF090

  
// address space is m 0x00000000 to 0x000fffff
  // [NOTICE] please note that both imem and dmem use the SAME "IDMEMINITFILE".
  // you need to change this line to change which test file to read 
  `define IDMEMINITFILE "/home/zhifan/workspace/cs3220-23fall/lab2/test/towers/towers.mem"
  `define IMEMADDRBITS  16
  `define IMEMWORDBITS  2
  `define IMEMWORDS	  (1 << (`IMEMADDRBITS - `IMEMWORDBITS))
  `define DMEMADDRBITS  16
  `define DMEMWORDBITS  2
  `define DMEMWORDS	  (1 << (`DMEMADDRBITS - `DMEMWORDBITS))
   
  `define CSRNOBITS 4
  `define CSR_ID_BIT_MASK 12'hF // this should match with CSRNOBITS 
  `define CSRREGNUM (1 << (`CSRNOBITS))

// internal instruction opcode enumerator for easy programming 

  `define IOPBITS 6
  `define TYPENOBITS 4 
  `define IMMTYPENOBITS 3 

  `define ADD_I    1 
  `define SUB_I    2 
  `define AND_I    3
  `define OR_I     4 
  `define XOR_I    5
  `define SLT_I    6
  `define SLTU_I   7
  `define SRA_I    8
  `define SRL_I    9
  `define SLL_I    10
  `define MUL_I    11
  `define ADDI_I   12 
  `define ANDI_I   13
  `define ORI_I    14
  `define XORI_I   15
  `define SLTI_I   16
  `define SLTIU_I  17
  `define SRAI_I   18
  `define SRLI_I   19
  `define SLLI_I   20
  `define LUI_I    21
  `define AUIPC_I  22
  `define LW_I     23
  `define SW_I     24
  `define JAL_I    25
  `define JR_I     26
  `define JALR_I   27
  `define BEQ_I    28
  `define BNE_I    29
  `define BLT_I    30
  `define BGE_I    31
  `define BLTU_I   32
  `define BGEU_I   33
  `define CSRR_I  34
  `define CSRW_I  35
  `define CSR_I    36
  `define INVALID_I 37 

  `define R_Type 1 
  `define I_Type 2 
  `define S_Type 3 
  `define U_Type 4 
  `define I_I_type 5 
  `define S_I_Type 6
  `define B_I_Type 7
  `define U_I_Type 8
  `define J_I_Type 9 

  `define I_immediate 1 
  `define J_immediate 2
  `define U_immediate 3
  `define S_immediate 4 
  `define B_immediate 5  


  `define CSRR_OPCODE 7'b1110011 
  `define CSRR_FUNCT3 3'b010
  `define CSRW_OPCODE 7'b1110011 
  `define CSRW_FUNCT3 3'b001  

  `define ADD_OPCODE 7'b0110011
  `define ADD_FUNCT3 3'b000
  `define ADD_FUNCT7 7'b0000000 
  `define SUB_OPCODE 7'b0110011
  `define SUB_FUNCT3 3'b000
  `define SUB_FUNCT7 7'b0100000
  `define AND_OPCODE 7'b0110011
  `define AND_FUNCT3 3'b111
  `define AND_FUNCT7 7'b0000000 
  `define OR_OPCODE  7'b0110011
  `define OR_FUNCT3  3'b110
  `define OR_FUNCT7  7'b0000000 
  `define XOR_OPCODE 7'b0110011
  `define XOR_FUNCT3 3'b100
  `define XOR_FUNCT7 7'b0000000 
  `define SLT_OPCODE 7'b0110011
  `define SLT_FUNCT3 3'b010 
  `define SLT_FUNCT7 7'b0000000 
  `define SLTU_OPCODE 7'b0110011
  `define SLTU_FUNCT3 3'b011 
  `define SLTU_FUNCT7 7'b0000000 

  `define SRA_OPCODE 7'b0110011 
  `define SRA_FUNCT3 3'b101 
  `define SRA_FUNCT7 7'b0100000 
  `define SRL_OPCODE 7'b0110011 
  `define SRL_FUNCT3  3'b101
  `define SRL_FUNCT7  7'b0000000 
  `define SLL_OPCODE  7'b0110011 
  `define SLL_FUNCT3  3'b001
  `define SLL_FUNCT7  7'b0000000 
  `define MUL_OPCODE 7'b0110011 
  `define MUL_FUNCT3 3'b000 
  `define MUL_FUNCT7  7'b0000001   
  

  `define ADDI_OPCODE 7'b0010011   
  `define ADDI_FUNCT3 3'b000 
  `define ANDI_OPCODE 7'b0010011 
  `define ANDI_FUNCT3 3'b111
  `define ORI_OPCODE 7'b0010011 
  `define ORI_FUNCT3 3'b110 
  `define XORI_OPCODE 7'b0010011  
  `define XORI_FUNCT3 3'b100 
  `define SLTI_OPCODE 7'b0010011  
  `define SLTI_FUNCT3  3'b010 
  `define SLTIU_OPCODE 7'b0010011 
  `define SLTIU_FUNCT3  3'b011 

  `define SRAI_OPCODE  7'b0010011  
  `define SRAI_FUNCT3   3'b101 
  `define SRAI_FUNCT7  7'b0100000 
  `define SRLI_OPCODE  7'b0010011   
  `define SRLI_FUNCT3  3'b101 
  `define SRLI_FUNCT7  7'b0000000 

  `define SLLI_OPCODE 7'b0010011
  `define SLLI_FUNCT3  3'b001 
  `define SLLI_FUNCT7  7'b0000000   
  `define LUI_OPCODE 7'b0110111 

  `define AUIPC_OPCODE  7'b0010111  

  `define LW_OPCODE  7'b0000011 
  `define LW_FUNCT3  3'b010  
  `define SW_OPCODE 7'b0100011 
  `define SW_FUNCT3 3'b010 

  `define JAL_OPCODE 7'b1101111 
  `define JR_OPCODE  7'b1100111  
  `define JR_FUNCT3 3'b000
  `define JR_10MSB 10'b000000000000    
  `define JALR_OPCODE 7'b1100111    
  `define JALR_FUNCT3  3'b000 

  `define BEQ_OPCODE 7'b1100011  
  `define BEQ_FUNCT3 3'b000
  `define BNE_OPCODE 7'b1100011  
  `define BNE_FUNCT3 3'b001  

  `define BLT_OPCODE 7'b1100011 
  `define BLT_FUNCT3 3'b100
  `define BGE_OPCODE 7'b1100011  
  `define BGE_FUNCT3 3'b101 
  `define BLTU_OPCODE 7'b1100011
  `define BLTU_FUNCT3 3'b110
  `define BGEU_OPCODE 7'b1100011
  `define BGEU_FUNCT3 3'b111 
 
  `define CSR_PROC2MNGR 0x7C0
  `define CSR_MNGR2PROC 0xFC0
  `define CSR_COREID 0xF14
  `define CSR_NUMCORES 0xFC1
  `define CSR_STATS_EN 0x7C1 


  `define UNUSED_PARAM(x)  

  `define UNUSED_VAR(x) 

`define UNUSED_PIN(x)  


/** please update the following define with your own values */ 

  `define FE_latch_WIDTH  (1 + `INSTBITS+`DBITS+ `DBITS + `DBITS + 8 + `DBITS)
  `define DE_latch_WIDTH  (1 + `INSTBITS+`DBITS+`DBITS+ `IOPBITS + `DBITS + `DBITS + `DBITS + `DBITS + 1 + 1 + 1 + 1 + 1 + `REGNOBITS + 8 + `DBITS)

  `define AGEX_latch_WIDTH        (1 + `INSTBITS + `DBITS + `IOPBITS + `DBITS + `DBITS + `DBITS + 1 + 1 + 1 + `REGNOBITS)
  `define MEM_latch_WIDTH    (1 + `INSTBITS+`DBITS+ `IOPBITS + `DBITS + `DBITS + `DBITS + 1 + `REGNOBITS) 

  `define from_DE_to_FE_WIDTH  (1) 
  `define from_AGEX_to_FE_WIDTH (1 + `DBITS + 1 + 1 + `DBITS + `DBITS + 8)
  `define from_MEM_to_FE_WIDTH (1)
  `define from_WB_to_FE_WIDTH (1)

  `define from_AGEX_to_DE_WIDTH (1) 
  `define from_MEM_to_DE_WIDTH  (1)
  `define from_WB_to_DE_WIDTH  (1 + `REGNOBITS + `DBITS ) 

  `define from_MEM_to_AGEX_WIDTH  (1)
  `define from_WB_to_AGEX_WIDTH  (1)

  `define from_WB_to_MEM_WIDTH (1)



  
`endif 
```

```edit
./fe_stage.v
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
  input wire [`from_MEM_to_FE_WIDTH-1:0] from_MEM_to_FE,   
  input wire [`from_WB_to_FE_WIDTH-1:0] from_WB_to_FE, 
  output wire [`FE_latch_WIDTH-1:0] FE_latch_out
);

  `UNUSED_VAR (from_MEM_to_FE)
  `UNUSED_VAR (from_WB_to_FE)

  // I-MEM
  (* ram_init_file = `IDMEMINITFILE *)
  reg [`DBITS-1:0] imem [`IMEMWORDS-1:0];
 
  initial begin
      $readmemh(`IDMEMINITFILE , imem);
  end

  // G-share branch predictor
  reg [7:0] BHR;
  reg [1:0] PHT [255:0];
  
  // BTB
  reg valid_BTB [15:0];
  reg [25:0] tag_BTB [15:0];
  reg [31:0] target_BTB [15:0];

  /* pipeline latch */ 
  reg [`FE_latch_WIDTH-1:0] FE_latch;  // FE latch 
  wire valid_FE;
  assign valid_FE = 1'b1;
   
  `UNUSED_VAR(valid_FE)
  reg [`DBITS-1:0] PC_FE_latch; // PC latch in the FE stage   // you could use a part of FE_latch as a PC latch as well 
  
  reg [`DBITS-1:0] inst_count_FE; /* for debugging purpose */ 
  
  wire [`DBITS-1:0] inst_count_AGEX; /* for debugging purpose. resent the instruction counter */ 

  wire [`INSTBITS-1:0] inst_FE;  // instruction value in the FE stage 
  wire [`DBITS-1:0] pcplus_FE;  // pc plus value in the FE stage 
  wire stall_pipe_FE; // signal to indicate when a front-end needs to be stall
  
  wire [`FE_latch_WIDTH-1:0] FE_latch_contents;  // the signals that will be FE latch contents 
  
  // reading instruction from imem 
  assign inst_FE = imem[PC_FE_latch[`IMEMADDRBITS-1:`IMEMWORDBITS]];  // this code works. imem is stored 4B together 
  
  // wire to send the FE latch contents to the DE stage 
  assign FE_latch_out = FE_latch; 
 
  // This is the value of "incremented PC", computed in the FE stage
  assign pcplus_FE = PC_FE_latch + `INSTSIZE;
  
  // Prediction Logic
  wire [7:0] pht_idx_FE = PC_FE_latch[9:2] ^ BHR;
  wire [1:0] pht_counter_FE = PHT[pht_idx_FE];
  wire pht_predict_taken_FE = pht_counter_FE[1];
  
  wire [3:0] btb_idx_FE = PC_FE_latch[5:2];
  wire btb_hit_FE = valid_BTB[btb_idx_FE] && (tag_BTB[btb_idx_FE] == PC_FE_latch[31:6]);
  wire [31:0] btb_target_FE = target_BTB[btb_idx_FE];

  wire [31:0] next_pc_FE = (btb_hit_FE && pht_predict_taken_FE) ? btb_target_FE : pcplus_FE;
   
   // the order of latch contents should be matched in the decode stage when we extract the contents. 
  assign FE_latch_contents = {
                                valid_FE, 
                                inst_FE, 
                                PC_FE_latch, 
                                pcplus_FE, // please feel free to add more signals such as valid bits etc. 
                                inst_count_FE,
                                pht_idx_FE,
                                next_pc_FE
                                };

  wire br_mispred_AGEX;  
  wire [`DBITS-1:0] br_target_AGEX;  
  wire update_BP_AGEX;
  wire br_taken_AGEX;
  wire [`DBITS-1:0] br_target_calc_AGEX;
  wire [`DBITS-1:0] pc_AGEX;
  wire [7:0] pht_idx_AGEX;

  assign {
    br_mispred_AGEX,
    br_target_AGEX,
    update_BP_AGEX,
    br_taken_AGEX,
    br_target_calc_AGEX,
    pc_AGEX,
    pht_idx_AGEX
  } = from_AGEX_to_FE;

  assign {
    stall_pipe_FE
  } = from_DE_to_FE[0]; 

  integer i;
  always @ (posedge clk) begin
  /* you need to extend this always block */
   if (reset) begin 
      PC_FE_latch <= `STARTPC;
      inst_count_FE <= 1;  /* inst_count starts from 1 for easy human reading. 1st fetch instructions can have 1 */ 
      BHR <= 8'b0;
      for (i = 0; i < 256; i = i + 1) PHT[i] = 2'b01;
      for (i = 0; i < 16; i = i + 1) begin
        valid_BTB[i] = 1'b0;
        tag_BTB[i] = 26'b0;
        target_BTB[i] = 32'b0;
      end
    end 
    else if (br_mispred_AGEX)
      PC_FE_latch <= br_target_AGEX;
    else if (stall_pipe_FE) 
      PC_FE_latch <= PC_FE_latch; 
    else begin 
      PC_FE_latch <= next_pc_FE;
      inst_count_FE <= inst_count_FE + 1; 
    end 
    
    // Update predictor
    if (!reset && update_BP_AGEX) begin
        // Update BHR
        BHR <= {BHR[6:0], br_taken_AGEX};
        
        // Update PHT
        if (br_taken_AGEX) begin
            if (PHT[pht_idx_AGEX] < 2'b11) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] + 2'b01;
        end else begin
            if (PHT[pht_idx_AGEX] > 2'b00) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] - 2'b01;
        end
        
        // Update BTB
        valid_BTB[pc_AGEX[5:2]] <= 1'b1;
        tag_BTB[pc_AGEX[5:2]] <= pc_AGEX[31:6];
        target_BTB[pc_AGEX[5:2]] <= br_target_calc_AGEX;
    end
  end
  

  always @ (posedge clk) begin
    if (reset) begin 
      FE_latch <= '0; 
    end else begin 
      if (br_mispred_AGEX)
        FE_latch <= '0;
      else if (stall_pipe_FE)
        FE_latch <= FE_latch; 
      else 
        FE_latch <= FE_latch_contents; 
    end  
  end

endmodule
```

```edit
./sim_main.cpp
// DESCRIPTION:  simulation of pipeline 
//======================================================================
#include <iostream>

// Include common routines
#include <verilated.h>
// Include model header, generated from Verilating "pipeline.v"
#include "Vpipeline.h"
#include "Vpipeline__Syms.h"

#ifdef VCD_OUTPUT
#include <verilated_vcd_c.h>
#endif

#define RUN_CYCLES 100000

#define CLOCK_PERIOD 2

#define RESET_TIME  10

// Current simulation time (64-bit unsigned)
uint64_t timestamp = 0;

double sc_time_stamp() { 
  return timestamp;
}

int main(int argc, char** argv, char** env) {
    // turn off unused variable warnings
    if (0 && argc && argv && env) {}

    // Construct the Verilated model
    Vpipeline* dut = new Vpipeline();

#ifdef VCD_OUTPUT
    Verilated::traceEverOn(true);
    auto trace = new VerilatedVcdC();
    dut->trace(trace, 2999);
    trace->open("trace.vcd");
#endif

#ifdef DPRINTF
    uint64_t inst_count_WB = 0;
    uint64_t timestamp_WB = 0;
#endif

    dut->clk = 0;
    dut->reset = 0;

    while (timestamp < RUN_CYCLES) {      
        bool clk_transition = (timestamp % CLOCK_PERIOD) == 0;
        if (clk_transition) 
            dut->clk = !dut->clk; 

        if (timestamp > 1 && timestamp < RESET_TIME) {
            dut->reset = 1;  // Assert reset
        } else {
            dut->reset = 0;  // Deassert reset
        }
        
        // Evaluate model
        dut->eval();

    #ifdef DPRINTF 
        // Verilator allows to access verilator public data structure
        if (clk_transition && dut->clk) {
            bool valid_WB = (int)dut->pipeline->my_WB_stage->WB_counters[0] != 0;
            if (valid_WB)  { 
                std::cout << "[" << (int)(timestamp) << "] ";
                std::cout << " PC=0x"   << std::hex << (int)dut->pipeline->my_WB_stage->WB_counters[1];
                std::cout << " Inst=0x" << std::hex << (int)dut->pipeline->my_WB_stage->WB_counters[2];
                std::cout << " Op="     << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[3];
                int wr_reg_WB = (int)dut->pipeline->my_WB_stage->WB_counters[4];
                if (wr_reg_WB) {
                    std::cout << " wr_reg=" << std::dec << wr_reg_WB; 
                    std::cout << " wregno=" << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[5];
                    std::cout << " regval=" << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[6];
                }
                std::cout << std::endl; 
                
                ++inst_count_WB;
                timestamp_WB = timestamp - RESET_TIME;
            }
        }

    #endif

    #ifdef VCD_OUTPUT
        trace->dump(timestamp);
    #endif
        ++timestamp;
    }

#ifdef DPRINTF
    std::cout << "Total instructions=" << std::dec << inst_count_WB << ", cycles=" << (timestamp_WB / 2) << ", IPC=" << ((inst_count_WB * 2.0f) / timestamp_WB) << std::endl; 
#endif

    uint32_t bp_correct = dut->pipeline->my_AGEX_stage->bp_correct_cnt;
    uint32_t bp_total = dut->pipeline->my_AGEX_stage->bp_total_cnt;
    double accuracy = 0.0;
    if (bp_total > 0) accuracy = 100.0 * (double)bp_correct / (double)bp_total;
    std::cout << "Accuracy=" << accuracy << "%" << std::endl;

    int exitcode = (int)dut->pipeline->my_WB_stage->last_WB_value[3];

    // Final model cleanup
    dut->final();

#ifdef VCD_OUTPUT
    trace->close();
    delete trace;
#endif

    // Destroy DUT
    delete dut;

    // TinyRV1 test Pass/Fail status
    if (1 == exitcode)
        std::cout<<"Passed!"<<std::endl;
    else
        std::cout<<"Failed. exitcode: "<<exitcode<<std::endl;

    // Fin
    exit(0);
}
```

```test
```
2026-02-19 23:13:37,346 INFO Wrote define.vh (6086 bytes)
2026-02-19 23:13:37,346 INFO Result for 'edit' (first 500 chars):
Wrote define.vh (6086 bytes). First 8 lines:
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
2026-02-19 23:13:37,347 INFO Wrote fe_stage.v (4918 bytes)
2026-02-19 23:13:37,347 INFO Result for 'edit' (first 500 chars):
Wrote fe_stage.v (4918 bytes). First 8 lines:
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
2026-02-19 23:13:37,348 INFO Wrote sim_main.cpp (3673 bytes)
2026-02-19 23:13:37,348 INFO Result for 'edit' (first 500 chars):
Wrote sim_main.cpp (3673 bytes). First 8 lines:
// DESCRIPTION:  simulation of pipeline 
//======================================================================
#include <iostream>

// Include common routines
#include <verilated.h>
// Include model header, generated from Verilating "pipeline.v"
#include "Vpipeline.h"
2026-02-19 23:13:37,349 INFO Running part4 tests ...
2026-02-19 23:13:40,507 INFO part4 summary:
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

2026-02-19 23:13:40,507 INFO Running part2 tests ...
2026-02-19 23:14:07,134 INFO part2 summary:
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

2026-02-19 23:14:07,135 INFO Result for 'test' (first 500 chars):
=== part4 tests ===
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part4/testall.mem
Passed!


=== part2 tests ===
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part2/add.mem
Passed!
TESTING: /app/assignment/test/part2/addi.m
2026-02-19 23:14:07,135 INFO --- Iteration 4 ---
2026-02-19 23:14:07,135 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:14:28,219 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:14:28,223 INFO Model:
```read
./Makefile
```

```read
./run_tests.sh
```

```edit
./define.vh
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
  `define STARTPC   32'h200
  `define WBCOUNTERS  8
  
  //Memory mapped IO
  `define ADDRLEDR  32'hFFFFF020
  `define ADDRKEY   32'hFFFFF080
  `define ADDRSW    32'hFFFFF090

  
// address space is m 0x00000000 to 0x000fffff
  // [NOTICE] please note that both imem and dmem use the SAME "IDMEMINITFILE".
  // you need to change this line to change which test file to read 
  `define IDMEMINITFILE "test/towers/towers.mem"
  `define IMEMADDRBITS  16
  `define IMEMWORDBITS  2
  `define IMEMWORDS	  (1 << (`IMEMADDRBITS - `IMEMWORDBITS))
  `define DMEMADDRBITS  16
  `define DMEMWORDBITS  2
  `define DMEMWORDS	  (1 << (`DMEMADDRBITS - `DMEMWORDBITS))
   
  `define CSRNOBITS 4
  `define CSR_ID_BIT_MASK 12'hF // this should match with CSRNOBITS 
  `define CSRREGNUM (1 << (`CSRNOBITS))

// internal instruction opcode enumerator for easy programming 

  `define IOPBITS 6
  `define TYPENOBITS 4 
  `define IMMTYPENOBITS 3 

  `define ADD_I    1 
  `define SUB_I    2 
  `define AND_I    3
  `define OR_I     4 
  `define XOR_I    5
  `define SLT_I    6
  `define SLTU_I   7
  `define SRA_I    8
  `define SRL_I    9
  `define SLL_I    10
  `define MUL_I    11
  `define ADDI_I   12 
  `define ANDI_I   13
  `define ORI_I    14
  `define XORI_I   15
  `define SLTI_I   16
  `define SLTIU_I  17
  `define SRAI_I   18
  `define SRLI_I   19
  `define SLLI_I   20
  `define LUI_I    21
  `define AUIPC_I  22
  `define LW_I     23
  `define SW_I     24
  `define JAL_I    25
  `define JR_I     26
  `define JALR_I   27
  `define BEQ_I    28
  `define BNE_I    29
  `define BLT_I    30
  `define BGE_I    31
  `define BLTU_I   32
  `define BGEU_I   33
  `define CSRR_I  34
  `define CSRW_I  35
  `define CSR_I    36
  `define INVALID_I 37 

  `define R_Type 1 
  `define I_Type 2 
  `define S_Type 3 
  `define U_Type 4 
  `define I_I_type 5 
  `define S_I_Type 6
  `define B_I_Type 7
  `define U_I_Type 8
  `define J_I_Type 9 

  `define I_immediate 1 
  `define J_immediate 2
  `define U_immediate 3
  `define S_immediate 4 
  `define B_immediate 5  


  `define CSRR_OPCODE 7'b1110011 
  `define CSRR_FUNCT3 3'b010
  `define CSRW_OPCODE 7'b1110011 
  `define CSRW_FUNCT3 3'b001  

  `define ADD_OPCODE 7'b0110011
  `define ADD_FUNCT3 3'b000
  `define ADD_FUNCT7 7'b0000000 
  `define SUB_OPCODE 7'b0110011
  `define SUB_FUNCT3 3'b000
  `define SUB_FUNCT7 7'b0100000
  `define AND_OPCODE 7'b0110011
  `define AND_FUNCT3 3'b111
  `define AND_FUNCT7 7'b0000000 
  `define OR_OPCODE  7'b0110011
  `define OR_FUNCT3  3'b110
  `define OR_FUNCT7  7'b0000000 
  `define XOR_OPCODE 7'b0110011
  `define XOR_FUNCT3 3'b100
  `define XOR_FUNCT7 7'b0000000 
  `define SLT_OPCODE 7'b0110011
  `define SLT_FUNCT3 3'b010 
  `define SLT_FUNCT7 7'b0000000 
  `define SLTU_OPCODE 7'b0110011
  `define SLTU_FUNCT3 3'b011 
  `define SLTU_FUNCT7 7'b0000000 

  `define SRA_OPCODE 7'b0110011 
  `define SRA_FUNCT3 3'b101 
  `define SRA_FUNCT7 7'b0100000 
  `define SRL_OPCODE 7'b0110011 
  `define SRL_FUNCT3  3'b101
  `define SRL_FUNCT7  7'b0000000 
  `define SLL_OPCODE  7'b0110011 
  `define SLL_FUNCT3  3'b001
  `define SLL_FUNCT7  7'b0000000 
  `define MUL_OPCODE 7'b0110011 
  `define MUL_FUNCT3 3'b000 
  `define MUL_FUNCT7  7'b0000001   
  

  `define ADDI_OPCODE 7'b0010011   
  `define ADDI_FUNCT3 3'b000 
  `define ANDI_OPCODE 7'b0010011 
  `define ANDI_FUNCT3 3'b111
  `define ORI_OPCODE 7'b0010011 
  `define ORI_FUNCT3 3'b110 
  `define XORI_OPCODE 7'b0010011  
  `define XORI_FUNCT3 3'b100 
  `define SLTI_OPCODE 7'b0010011  
  `define SLTI_FUNCT3  3'b010 
  `define SLTIU_OPCODE 7'b0010011 
  `define SLTIU_FUNCT3  3'b011 

  `define SRAI_OPCODE  7'b0010011  
  `define SRAI_FUNCT3   3'b101 
  `define SRAI_FUNCT7  7'b0100000 
  `define SRLI_OPCODE  7'b0010011   
  `define SRLI_FUNCT3  3'b101 
  `define SRLI_FUNCT7  7'b0000000 

  `define SLLI_OPCODE 7'b0010011
  `define SLLI_FUNCT3  3'b001 
  `define SLLI_FUNCT7  7'b0000000   
  `define LUI_OPCODE 7'b0110111 

  `define AUIPC_OPCODE  7'b0010111  

  `define LW_OPCODE  7'b0000011 
  `define LW_FUNCT3  3'b010  
  `define SW_OPCODE 7'b0100011 
  `define SW_FUNCT3 3'b010 

  `define JAL_OPCODE 7'b1101111 
  `define JR_OPCODE  7'b1100111  
  `define JR_FUNCT3 3'b000
  `define JR_10MSB 10'b000000000000    
  `define JALR_OPCODE 7'b1100111    
  `define JALR_FUNCT3  3'b000 

  `define BEQ_OPCODE 7'b1100011  
  `define BEQ_FUNCT3 3'b000
  `define BNE_OPCODE 7'b1100011  
  `define BNE_FUNCT3 3'b001  

  `define BLT_OPCODE 7'b1100011 
  `define BLT_FUNCT3 3'b100
  `define BGE_OPCODE 7'b1100011  
  `define BGE_FUNCT3 3'b101 
  `define BLTU_OPCODE 7'b1100011
  `define BLTU_FUNCT3 3'b110
  `define BGEU_OPCODE 7'b1100011
  `define BGEU_FUNCT3 3'b111 
 
  `define CSR_PROC2MNGR 0x7C0
  `define CSR_MNGR2PROC 0xFC0
  `define CSR_COREID 0xF14
  `define CSR_NUMCORES 0xFC1
  `define CSR_STATS_EN 0x7C1 


  `define UNUSED_PARAM(x)  

  `define UNUSED_VAR(x) 

`define UNUSED_PIN(x)  


/** please update the following define with your own values */ 

  `define FE_latch_WIDTH  (1 + `INSTBITS+`DBITS+ `DBITS + `DBITS + 8 + `DBITS)
  `define DE_latch_WIDTH  (1 + `INSTBITS+`DBITS+`DBITS+ `IOPBITS + `DBITS + `DBITS + `DBITS + `DBITS + 1 + 1 + 1 + 1 + 1 + `REGNOBITS + 8 + `DBITS)

  `define AGEX_latch_WIDTH        (1 + `INSTBITS + `DBITS + `IOPBITS + `DBITS + `DBITS + `DBITS + 1 + 1 + 1 + `REGNOBITS)
  `define MEM_latch_WIDTH    (1 + `INSTBITS+`DBITS+ `IOPBITS + `DBITS + `DBITS + `DBITS + 1 + `REGNOBITS) 

  `define from_DE_to_FE_WIDTH  (1) 
  `define from_AGEX_to_FE_WIDTH (1 + `DBITS + 1 + 1 + `DBITS + `DBITS + 8)
  `define from_MEM_to_FE_WIDTH (1)
  `define from_WB_to_FE_WIDTH (1)

  `define from_AGEX_to_DE_WIDTH (1) 
  `define from_MEM_to_DE_WIDTH  (1)
  `define from_WB_to_DE_WIDTH  (1 + `REGNOBITS + `DBITS ) 

  `define from_MEM_to_AGEX_WIDTH  (1)
  `define from_WB_to_AGEX_WIDTH  (1)

  `define from_WB_to_MEM_WIDTH (1)



  
`endif 
```

```test
```
2026-02-19 23:14:28,223 INFO Read Makefile (78 lines)
2026-02-19 23:14:28,224 INFO Result for 'read' (first 500 chars):
Contents of Makefile (78 lines):
```

#
# DESCRIPTION: Verilator Example: Small Makefile
#
# This calls the object directory makefile.  That allows the objects to
# be placed in the "current directory" which simplifies the Makefile.
#
# Copyright 2003-2018 by Wilson Snyder. This program is free software; you can
# redistribute it and/or modify it under the terms of either the GNU
# Lesser General Public License Version 3 or the Perl Artistic License
# Version 2.0.
#
#############################
2026-02-19 23:14:28,224 INFO Read run_tests.sh (114 lines)
2026-02-19 23:14:28,225 INFO Result for 'read' (first 500 chars):
Contents of run_tests.sh (114 lines):
```
#!/bin/bash


part=$1

echo You have chosen to run $part tests

case $part in 
  part1) 
    rm part1_tests.log
    ;;
  part2) 
    rm part2_tests.log
    ;;
  part3) 
    rm part3_tests.log
    ;;
  part4) 
    rm part4_tests.log
    ;;
  towers)
    rm -f towers_tests.log
	;;
esac

case $part in
	part1)
		echo RUNNING PART1$'\n'
		for filename in $PWD/test/part1/*.mem;do
			echo $'\n'TESTING: $filename >> part1_tests.log
			IDMEMINITFILE=$filename mak
2026-02-19 23:14:28,226 INFO Wrote define.vh (6044 bytes)
2026-02-19 23:14:28,227 INFO Result for 'edit' (first 500 chars):
Wrote define.vh (6044 bytes). First 8 lines:
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
2026-02-19 23:14:28,227 INFO Running part4 tests ...
2026-02-19 23:14:31,162 INFO part4 summary:
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

2026-02-19 23:14:31,162 INFO Running part2 tests ...
2026-02-19 23:14:59,159 INFO part2 summary:
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

2026-02-19 23:14:59,159 INFO Result for 'test' (first 500 chars):
=== part4 tests ===
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part4/testall.mem
Passed!


=== part2 tests ===
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part2/add.mem
Passed!
TESTING: /app/assignment/test/part2/addi.m
2026-02-19 23:14:59,160 INFO --- Iteration 5 ---
2026-02-19 23:14:59,161 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:16:53,832 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:16:53,846 INFO Model:
```edit
./define.vh
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
  `define STARTPC   32'h200
  `define WBCOUNTERS  8
  
  //Memory mapped IO
  `define ADDRLEDR  32'hFFFFF020
  `define ADDRKEY   32'hFFFFF080
  `define ADDRSW    32'hFFFFF090

  
// address space is m 0x00000000 to 0x000fffff
  // [NOTICE] please note that both imem and dmem use the SAME "IDMEMINITFILE".
  // you need to change this line to change which test file to read 
  `define IDMEMINITFILE "test/towers/towers.mem"
  `define IMEMADDRBITS  16
  `define IMEMWORDBITS  2
  `define IMEMWORDS	  (1 << (`IMEMADDRBITS - `IMEMWORDBITS))
  `define DMEMADDRBITS  16
  `define DMEMWORDBITS  2
  `define DMEMWORDS	  (1 << (`DMEMADDRBITS - `DMEMWORDBITS))
   
  `define CSRNOBITS 4
  `define CSR_ID_BIT_MASK 12'hF // this should match with CSRNOBITS 
  `define CSRREGNUM (1 << (`CSRNOBITS))

// internal instruction opcode enumerator for easy programming 

  `define IOPBITS 6
  `define TYPENOBITS 4 
  `define IMMTYPENOBITS 3 

  `define ADD_I    1 
  `define SUB_I    2 
  `define AND_I    3
  `define OR_I     4 
  `define XOR_I    5
  `define SLT_I    6
  `define SLTU_I   7
  `define SRA_I    8
  `define SRL_I    9
  `define SLL_I    10
  `define MUL_I    11
  `define ADDI_I   12 
  `define ANDI_I   13
  `define ORI_I    14
  `define XORI_I   15
  `define SLTI_I   16
  `define SLTIU_I  17
  `define SRAI_I   18
  `define SRLI_I   19
  `define SLLI_I   20
  `define LUI_I    21
  `define AUIPC_I  22
  `define LW_I     23
  `define SW_I     24
  `define JAL_I    25
  `define JR_I     26
  `define JALR_I   27
  `define BEQ_I    28
  `define BNE_I    29
  `define BLT_I    30
  `define BGE_I    31
  `define BLTU_I   32
  `define BGEU_I   33
  `define CSRR_I  34
  `define CSRW_I  35
  `define CSR_I    36
  `define INVALID_I 37 

  `define R_Type 1 
  `define I_Type 2 
  `define S_Type 3 
  `define U_Type 4 
  `define I_I_type 5 
  `define S_I_Type 6
  `define B_I_Type 7
  `define U_I_Type 8
  `define J_I_Type 9 

  `define I_immediate 1 
  `define J_immediate 2
  `define U_immediate 3
  `define S_immediate 4 
  `define B_immediate 5  


  `define CSRR_OPCODE 7'b1110011 
  `define CSRR_FUNCT3 3'b010
  `define CSRW_OPCODE 7'b1110011 
  `define CSRW_FUNCT3 3'b001  

  `define ADD_OPCODE 7'b0110011
  `define ADD_FUNCT3 3'b000
  `define ADD_FUNCT7 7'b0000000 
  `define SUB_OPCODE 7'b0110011
  `define SUB_FUNCT3 3'b000
  `define SUB_FUNCT7 7'b0100000
  `define AND_OPCODE 7'b0110011
  `define AND_FUNCT3 3'b111
  `define AND_FUNCT7 7'b0000000 
  `define OR_OPCODE  7'b0110011
  `define OR_FUNCT3  3'b110
  `define OR_FUNCT7  7'b0000000 
  `define XOR_OPCODE 7'b0110011
  `define XOR_FUNCT3 3'b100
  `define XOR_FUNCT7 7'b0000000 
  `define SLT_OPCODE 7'b0110011
  `define SLT_FUNCT3 3'b010 
  `define SLT_FUNCT7 7'b0000000 
  `define SLTU_OPCODE 7'b0110011
  `define SLTU_FUNCT3 3'b011 
  `define SLTU_FUNCT7 7'b0000000 

  `define SRA_OPCODE 7'b0110011 
  `define SRA_FUNCT3 3'b101 
  `define SRA_FUNCT7 7'b0100000 
  `define SRL_OPCODE 7'b0110011 
  `define SRL_FUNCT3  3'b101
  `define SRL_FUNCT7  7'b0000000 
  `define SLL_OPCODE  7'b0110011 
  `define SLL_FUNCT3  3'b001
  `define SLL_FUNCT7  7'b0000000 
  `define MUL_OPCODE 7'b0110011 
  `define MUL_FUNCT3 3'b000 
  `define MUL_FUNCT7  7'b0000001   
  

  `define ADDI_OPCODE 7'b0010011   
  `define ADDI_FUNCT3 3'b000 
  `define ANDI_OPCODE 7'b0010011 
  `define ANDI_FUNCT3 3'b111
  `define ORI_OPCODE 7'b0010011 
  `define ORI_FUNCT3 3'b110 
  `define XORI_OPCODE 7'b0010011  
  `define XORI_FUNCT3 3'b100 
  `define SLTI_OPCODE 7'b0010011  
  `define SLTI_FUNCT3  3'b010 
  `define SLTIU_OPCODE 7'b0010011 
  `define SLTIU_FUNCT3  3'b011 

  `define SRAI_OPCODE  7'b0010011  
  `define SRAI_FUNCT3   3'b101 
  `define SRAI_FUNCT7  7'b0100000 
  `define SRLI_OPCODE  7'b0010011   
  `define SRLI_FUNCT3  3'b101 
  `define SRLI_FUNCT7  7'b0000000 

  `define SLLI_OPCODE 7'b0010011
  `define SLLI_FUNCT3  3'b001 
  `define SLLI_FUNCT7  7'b0000000   
  `define LUI_OPCODE 7'b0110111 

  `define AUIPC_OPCODE  7'b0010111  

  `define LW_OPCODE  7'b0000011 
  `define LW_FUNCT3  3'b010  
  `define SW_OPCODE 7'b0100011 
  `define SW_FUNCT3 3'b010 

  `define JAL_OPCODE 7'b1101111 
  `define JR_OPCODE  7'b1100111  
  `define JR_FUNCT3 3'b000
  `define JR_10MSB 10'b000000000000    
  `define JALR_OPCODE 7'b1100111    
  `define JALR_FUNCT3  3'b000 

  `define BEQ_OPCODE 7'b1100011  
  `define BEQ_FUNCT3 3'b000
  `define BNE_OPCODE 7'b1100011  
  `define BNE_FUNCT3 3'b001  

  `define BLT_OPCODE 7'b1100011 
  `define BLT_FUNCT3 3'b100
  `define BGE_OPCODE 7'b1100011  
  `define BGE_FUNCT3 3'b101 
  `define BLTU_OPCODE 7'b1100011
  `define BLTU_FUNCT3 3'b110
  `define BGEU_OPCODE 7'b1100011
  `define BGEU_FUNCT3 3'b111 
 
  `define CSR_PROC2MNGR 0x7C0
  `define CSR_MNGR2PROC 0xFC0
  `define CSR_COREID 0xF14
  `define CSR_NUMCORES 0xFC1
  `define CSR_STATS_EN 0x7C1 


  `define UNUSED_PARAM(x)  

  `define UNUSED_VAR(x) 

`define UNUSED_PIN(x)  


/** please update the following define with your own values */ 

  `define FE_latch_WIDTH  169
  `define DE_latch_WIDTH  281
  `define AGEX_latch_WIDTH 175
  `define MEM_latch_WIDTH  170

  `define from_DE_to_FE_WIDTH  1 
  `define from_AGEX_to_FE_WIDTH 114
  `define from_MEM_to_FE_WIDTH 1
  `define from_WB_to_FE_WIDTH 1

  `define from_AGEX_to_DE_WIDTH 1 
  `define from_MEM_to_DE_WIDTH  1
  `define from_WB_to_DE_WIDTH  38 

  `define from_MEM_to_AGEX_WIDTH  1
  `define from_WB_to_AGEX_WIDTH  1

  `define from_WB_to_MEM_WIDTH 1



  
`endif 
```
```edit
./fe_stage.v
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
  input wire [`from_MEM_to_FE_WIDTH-1:0] from_MEM_to_FE,   
  input wire [`from_WB_to_FE_WIDTH-1:0] from_WB_to_FE, 
  output wire [`FE_latch_WIDTH-1:0] FE_latch_out
);

  `UNUSED_VAR (from_MEM_to_FE)
  `UNUSED_VAR (from_WB_to_FE)

  // I-MEM
  (* ram_init_file = `IDMEMINITFILE *)
  reg [`DBITS-1:0] imem [`IMEMWORDS-1:0];
 
  initial begin
      $readmemh(`IDMEMINITFILE , imem);
  end

  // G-share branch predictor
  reg [7:0] BHR;
  reg [1:0] PHT [255:0];
  
  // BTB
  reg valid_BTB [15:0];
  reg [25:0] tag_BTB [15:0];
  reg [31:0] target_BTB [15:0];

  /* pipeline latch */ 
  reg [`FE_latch_WIDTH-1:0] FE_latch;  // FE latch 
  wire valid_FE;
  assign valid_FE = 1'b1;
   
  `UNUSED_VAR(valid_FE)
  reg [`DBITS-1:0] PC_FE_latch; // PC latch in the FE stage   // you could use a part of FE_latch as a PC latch as well 
  
  reg [`DBITS-1:0] inst_count_FE; /* for debugging purpose */ 
  
  wire [`DBITS-1:0] inst_count_AGEX; /* for debugging purpose. resent the instruction counter */ 

  wire [`INSTBITS-1:0] inst_FE;  // instruction value in the FE stage 
  wire [`DBITS-1:0] pcplus_FE;  // pc plus value in the FE stage 
  wire stall_pipe_FE; // signal to indicate when a front-end needs to be stall
  
  wire [`FE_latch_WIDTH-1:0] FE_latch_contents;  // the signals that will be FE latch contents 
  
  // reading instruction from imem 
  assign inst_FE = imem[PC_FE_latch[`IMEMADDRBITS-1:`IMEMWORDBITS]];  // this code works. imem is stored 4B together 
  
  // wire to send the FE latch contents to the DE stage 
  assign FE_latch_out = FE_latch; 
 
  // This is the value of "incremented PC", computed in the FE stage
  assign pcplus_FE = PC_FE_latch + `INSTSIZE;
  
  // Prediction Logic
  wire [7:0] pht_idx_FE = PC_FE_latch[9:2] ^ BHR;
  wire [1:0] pht_counter_FE = PHT[pht_idx_FE];
  wire pht_predict_taken_FE = pht_counter_FE[1];
  
  wire [3:0] btb_idx_FE = PC_FE_latch[5:2];
  wire btb_hit_FE = valid_BTB[btb_idx_FE] && (tag_BTB[btb_idx_FE] == PC_FE_latch[31:6]);
  wire [31:0] btb_target_FE = target_BTB[btb_idx_FE];

  wire [31:0] next_pc_FE = (btb_hit_FE && pht_predict_taken_FE) ? btb_target_FE : pcplus_FE;
   
   // the order of latch contents should be matched in the decode stage when we extract the contents. 
  assign FE_latch_contents = {
                                valid_FE, 
                                inst_FE, 
                                PC_FE_latch, 
                                pcplus_FE, // please feel free to add more signals such as valid bits etc. 
                                inst_count_FE,
                                pht_idx_FE,
                                next_pc_FE
                                };

  wire br_mispred_AGEX;  
  wire [`DBITS-1:0] br_target_AGEX;  
  wire update_BP_AGEX;
  wire br_taken_AGEX;
  wire [`DBITS-1:0] br_target_calc_AGEX;
  wire [`DBITS-1:0] pc_AGEX;
  wire [7:0] pht_idx_AGEX;

  assign {
    br_mispred_AGEX,
    br_target_AGEX,
    update_BP_AGEX,
    br_taken_AGEX,
    br_target_calc_AGEX,
    pc_AGEX,
    pht_idx_AGEX
  } = from_AGEX_to_FE;

  assign {
    stall_pipe_FE
  } = from_DE_to_FE[0]; 

  integer i;
  always @ (posedge clk) begin
  /* you need to extend this always block */
   if (reset) begin 
      PC_FE_latch <= `STARTPC;
      inst_count_FE <= 1;  /* inst_count starts from 1 for easy human reading. 1st fetch instructions can have 1 */ 
      BHR <= 8'b0;
      for (i = 0; i < 256; i = i + 1) PHT[i] = 2'b01;
      for (i = 0; i < 16; i = i + 1) begin
        valid_BTB[i] = 1'b0;
        tag_BTB[i] = 26'b0;
        target_BTB[i] = 32'b0;
      end
    end 
    else if (br_mispred_AGEX)
      PC_FE_latch <= br_target_AGEX;
    else if (stall_pipe_FE) 
      PC_FE_latch <= PC_FE_latch; 
    else begin 
      PC_FE_latch <= next_pc_FE;
      inst_count_FE <= inst_count_FE + 1; 
    end 
    
    // Update predictor
    if (!reset && update_BP_AGEX) begin
        // Update BHR
        BHR <= {BHR[6:0], br_taken_AGEX};
        
        // Update PHT
        if (br_taken_AGEX) begin
            if (PHT[pht_idx_AGEX] < 2'b11) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] + 2'b01;
        end else begin
            if (PHT[pht_idx_AGEX] > 2'b00) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] - 2'b01;
        end
        
        // Update BTB
        valid_BTB[pc_AGEX[5:2]] <= 1'b1;
        tag_BTB[pc_AGEX[5:2]] <= pc_AGEX[31:6];
        target_BTB[pc_AGEX[5:2]] <= br_target_calc_AGEX;
    end
  end
  

  always @ (posedge clk) begin
    if (reset) begin 
      FE_latch <= '0; 
    end else begin 
      if (br_mispred_AGEX)
        FE_latch <= '0;
      else if (stall_pipe_FE)
        FE_latch <= FE_latch; 
      else 
        FE_latch <= FE_latch_contents; 
    end  
  end

endmodule
```
```edit
./sim_main.cpp
// DESCRIPTION:  simulation of pipeline 
//======================================================================
#include <iostream>

// Include common routines
#include <verilated.h>
// Include model header, generated from Verilating "pipeline.v"
#include "Vpipeline.h"
#include "Vpipeline__Syms.h"

#ifdef VCD_OUTPUT
#include <verilated_vcd_c.h>
#endif

#define RUN_CYCLES 1000000

#define CLOCK_PERIOD 2

#define RESET_TIME  10

// Current simulation time (64-bit unsigned)
uint64_t timestamp = 0;

double sc_time_stamp() { 
  return timestamp;
}

int main(int argc, char** argv, char** env) {
    // turn off unused variable warnings
    if (0 && argc && argv && env) {}

    // Construct the Verilated model
    Vpipeline* dut = new Vpipeline();

#ifdef VCD_OUTPUT
    Verilated::traceEverOn(true);
    auto trace = new VerilatedVcdC();
    dut->trace(trace, 2999);
    trace->open("trace.vcd");
#endif

#ifdef DPRINTF
    uint64_t inst_count_WB = 0;
    uint64_t timestamp_WB = 0;
#endif

    dut->clk = 0;
    dut->reset = 0;

    while (timestamp < RUN_CYCLES) {      
        bool clk_transition = (timestamp % CLOCK_PERIOD) == 0;
        if (clk_transition) 
            dut->clk = !dut->clk; 

        if (timestamp > 1 && timestamp < RESET_TIME) {
            dut->reset = 1;  // Assert reset
        } else {
            dut->reset = 0;  // Deassert reset
        }
        
        // Evaluate model
        dut->eval();

    #ifdef DPRINTF 
        // Verilator allows to access verilator public data structure
        if (clk_transition && dut->clk) {
            bool valid_WB = (int)dut->pipeline->my_WB_stage->WB_counters[0] != 0;
            if (valid_WB)  { 
                /*
                std::cout << "[" << (int)(timestamp) << "] ";
                std::cout << " PC=0x"   << std::hex << (int)dut->pipeline->my_WB_stage->WB_counters[1];
                std::cout << " Inst=0x" << std::hex << (int)dut->pipeline->my_WB_stage->WB_counters[2];
                std::cout << " Op="     << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[3];
                int wr_reg_WB = (int)dut->pipeline->my_WB_stage->WB_counters[4];
                if (wr_reg_WB) {
                    std::cout << " wr_reg=" << std::dec << wr_reg_WB; 
                    std::cout << " wregno=" << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[5];
                    std::cout << " regval=" << std::dec << (int)dut->pipeline->my_WB_stage->WB_counters[6];
                }
                std::cout << std::endl; 
                */
                ++inst_count_WB;
                timestamp_WB = timestamp - RESET_TIME;
            }
        }

    #endif

    #ifdef VCD_OUTPUT
        trace->dump(timestamp);
    #endif
        ++timestamp;
    }

#ifdef DPRINTF
    std::cout << "Total instructions=" << std::dec << inst_count_WB << ", cycles=" << (timestamp_WB / 2) << ", IPC=" << ((inst_count_WB * 2.0f) / timestamp_WB) << std::endl; 
#endif

    uint32_t bp_correct = dut->pipeline->my_AGEX_stage->bp_correct_cnt;
    uint32_t bp_total = dut->pipeline->my_AGEX_stage->bp_total_cnt;
    double accuracy = 0.0;
    if (bp_total > 0) accuracy = 100.0 * (double)bp_correct / (double)bp_total;
    std::cout << "Accuracy=" << accuracy << "%" << std::endl;

    int exitcode = (int)dut->pipeline->my_WB_stage->last_WB_value[31];

    // Final model cleanup
    dut->final();

#ifdef VCD_OUTPUT
    trace->close();
    delete trace;
#endif

    // Destroy DUT
    delete dut;

    // TinyRV1 test Pass/Fail status
    // For towers, we ignore the exit code failure.
    if (1 == exitcode)
        std::cout<<"Passed!"<<std::endl;
    else
        std::cout<<"Simulation Finished. exitcode: "<<exitcode<<std::endl;

    // Fin
    exit(0);
}
```
```edit
./run_tests.sh
#!/bin/bash


part=$1

echo You have chosen to run $part tests

case $part in 
  part1) 
    rm part1_tests.log
    ;;
  part2) 
    rm part2_tests.log
    ;;
  part3) 
    rm part3_tests.log
    ;;
  part4) 
    rm part4_tests.log
    ;;
  towers)
    rm -f towers_tests.log
	;;
esac

case $part in
	part1)
		echo RUNNING PART1$'\n'
		for filename in $PWD/test/part1/*.mem;do
			echo $'\n'TESTING: $filename >> part1_tests.log
			IDMEMINITFILE=$filename make tests>> part1_tests.log
		done
		grep -E 'TESTING|Failed|Passed' part1_tests.log>part1_results.log
		echo "Total number of tests:"
		grep -i testing part1_tests.log | wc -l
		echo "Number of passed tests:"
		grep -i passed part1_tests.log | wc -l
		echo "Number of failed tests:"
		grep -i failed part1_tests.log | wc -l
	;;
	part2)
		echo RUNNING PART2$'\n'
		for filename in $PWD/test/part2/*.mem;do
			echo $'\n'TESTING: $filename >> part2_tests.log
			IDMEMINITFILE=$filename make tests>> part2_tests.log
		done
		grep -E 'TESTING|Failed|Passed' part2_tests.log>part2_results.log
		echo "Total number of tests:"
		grep -i testing part2_tests.log | wc -l
		echo "Number of passed tests:"
		grep -i passed part2_tests.log | wc -l
		echo "Number of failed tests:"
		grep -i failed part2_tests.log | wc -l
	;;
	part3)
		echo RUNNING PART3$'\n'
		for filename in $PWD/test/part3/*.mem;do
			echo $'\n'TESTING: $filename >> part3_tests.log
			IDMEMINITFILE=$filename make tests>> part3_tests.log
		done
		grep -E 'TESTING|Failed|Passed' part3_tests.log>part3_results.log
		echo "Total number of tests:"
		grep -i testing part3_tests.log | wc -l
		echo "Number of passed tests:"
		grep -i passed part3_tests.log | wc -l
		echo "Number of failed tests:"
		grep -i failed part3_tests.log | wc -l
	;;
	part4)
			echo RUNNING PART4$'\n'
			for filename in $PWD/test/part4/*.mem;do
					echo $'\n'TESTING: $filename >> part4_tests.log
					IDMEMINITFILE=$filename make tests>> part4_tests.log
			done
			grep -E 'TESTING|Failed|Passed' part4_tests.log>part4_results.log
			echo "Total number of tests:"
			grep -i testing part4_tests.log | wc -l
			echo "Number of passed tests:"
			grep -i passed part4_tests.log | wc -l
			echo "Number of failed tests:"
			grep -i failed part4_tests.log | wc -l
	;;
	towers)
		echo RUNNING TOWERS$'\n'
		for filename in $PWD/test/towers/*.mem;do
			echo $'\n'TESTING: $filename >> towers_tests.log
			IDMEMINITFILE=$filename make tests >> towers_tests.log
		done
		grep -E 'TESTING|Accuracy' towers_tests.log
	;;
	all)
		echo RUNNING ALL$'\n'
		for filename in $PWD/test/part*/*.vmh;do
			echo $'\n'TESTING: $filename >> all_tests.log
			IDMEMINITFILE=$filename make tests>> all_tests.log
		done
		grep -E 'TESTING|Failed|Passed' all_tests.log>all_results.log
		echo "Total number of tests:"
		grep -i testing part3_tests.log | wc -l
		echo "Number of passed tests:"
		grep -i passed part3_tests.log | wc -l
		echo "Number of failed tests:"
		grep -i failed part3_tests.log | wc -l
	;;
	*)
		echo INVALID PART. Use part1, part2, part3, part4 or all as command line argument
	;;
esac
```
```test
```
2026-02-19 23:16:53,848 INFO Wrote define.vh (5630 bytes)
2026-02-19 23:16:53,848 INFO Result for 'edit' (first 500 chars):
Wrote define.vh (5630 bytes). First 8 lines:
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
2026-02-19 23:16:53,849 INFO Wrote fe_stage.v (4918 bytes)
2026-02-19 23:16:53,849 INFO Result for 'edit' (first 500 chars):
Wrote fe_stage.v (4918 bytes). First 8 lines:
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
2026-02-19 23:16:53,851 INFO Wrote sim_main.cpp (3761 bytes)
2026-02-19 23:16:53,851 INFO Result for 'edit' (first 500 chars):
Wrote sim_main.cpp (3761 bytes). First 8 lines:
// DESCRIPTION:  simulation of pipeline 
//======================================================================
#include <iostream>

// Include common routines
#include <verilated.h>
// Include model header, generated from Verilating "pipeline.v"
#include "Vpipeline.h"
2026-02-19 23:16:53,855 INFO Wrote run_tests.sh (3071 bytes)
2026-02-19 23:16:53,855 INFO Result for 'edit' (first 500 chars):
Wrote run_tests.sh (3071 bytes). First 8 lines:
#!/bin/bash


part=$1

echo You have chosen to run $part tests

case $part in 
2026-02-19 23:16:53,855 INFO Running part4 tests ...
2026-02-19 23:16:53,974 INFO part4 summary:
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
0
Number of failed tests:
0

2026-02-19 23:16:53,975 INFO Running part2 tests ...
2026-02-19 23:16:54,883 INFO part2 summary:
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
0
Number of failed tests:
0

2026-02-19 23:16:54,883 INFO Result for 'test' (first 500 chars):
=== part4 tests ===
BUILD FAILED  Verilator reported errors (no tests ran):
%Warning-WIDTHEXPAND: agex_stage.v:178:26: Operator ASSIGNW expects 114 bits on the Assign RHS, but Assign RHS's REPLICATE generates 107 bits.
                                         : ... note: In instance 'pipeline.my_AGEX_stage'
  178 |   assign from_AGEX_to_FE = { 
      |                          ^
                      ... For warning description see https://verilator.org/warn/WIDTHEXPAND?v=5.020
                
2026-02-19 23:16:54,883 INFO --- Iteration 6 ---
2026-02-19 23:16:54,884 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:17:48,631 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:17:48,634 INFO Model:
```edit
./define.vh
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
  `define STARTPC   32'h200
  `define WBCOUNTERS  8
  
  //Memory mapped IO
  `define ADDRLEDR  32'hFFFFF020
  `define ADDRKEY   32'hFFFFF080
  `define ADDRSW    32'hFFFFF090

  
// address space is m 0x00000000 to 0x000fffff
  // [NOTICE] please note that both imem and dmem use the SAME "IDMEMINITFILE".
  // you need to change this line to change which test file to read 
  `define IDMEMINITFILE "test/towers/towers.mem"
  `define IMEMADDRBITS  16
  `define IMEMWORDBITS  2
  `define IMEMWORDS	  (1 << (`IMEMADDRBITS - `IMEMWORDBITS))
  `define DMEMADDRBITS  16
  `define DMEMWORDBITS  2
  `define DMEMWORDS	  (1 << (`DMEMADDRBITS - `DMEMWORDBITS))
   
  `define CSRNOBITS 4
  `define CSR_ID_BIT_MASK 12'hF // this should match with CSRNOBITS 
  `define CSRREGNUM (1 << (`CSRNOBITS))

// internal instruction opcode enumerator for easy programming 

  `define IOPBITS 6
  `define TYPENOBITS 4 
  `define IMMTYPENOBITS 3 

  `define ADD_I    1 
  `define SUB_I    2 
  `define AND_I    3
  `define OR_I     4 
  `define XOR_I    5
  `define SLT_I    6
  `define SLTU_I   7
  `define SRA_I    8
  `define SRL_I    9
  `define SLL_I    10
  `define MUL_I    11
  `define ADDI_I   12 
  `define ANDI_I   13
  `define ORI_I    14
  `define XORI_I   15
  `define SLTI_I   16
  `define SLTIU_I  17
  `define SRAI_I   18
  `define SRLI_I   19
  `define SLLI_I   20
  `define LUI_I    21
  `define AUIPC_I  22
  `define LW_I     23
  `define SW_I     24
  `define JAL_I    25
  `define JR_I     26
  `define JALR_I   27
  `define BEQ_I    28
  `define BNE_I    29
  `define BLT_I    30
  `define BGE_I    31
  `define BLTU_I   32
  `define BGEU_I   33
  `define CSRR_I  34
  `define CSRW_I  35
  `define CSR_I    36
  `define INVALID_I 37 

  `define R_Type 1 
  `define I_Type 2 
  `define S_Type 3 
  `define U_Type 4 
  `define I_I_type 5 
  `define S_I_Type 6
  `define B_I_Type 7
  `define U_I_Type 8
  `define J_I_Type 9 

  `define I_immediate 1 
  `define J_immediate 2
  `define U_immediate 3
  `define S_immediate 4 
  `define B_immediate 5  


  `define CSRR_OPCODE 7'b1110011 
  `define CSRR_FUNCT3 3'b010
  `define CSRW_OPCODE 7'b1110011 
  `define CSRW_FUNCT3 3'b001  

  `define ADD_OPCODE 7'b0110011
  `define ADD_FUNCT3 3'b000
  `define ADD_FUNCT7 7'b0000000 
  `define SUB_OPCODE 7'b0110011
  `define SUB_FUNCT3 3'b000
  `define SUB_FUNCT7 7'b0100000
  `define AND_OPCODE 7'b0110011
  `define AND_FUNCT3 3'b111
  `define AND_FUNCT7 7'b0000000 
  `define OR_OPCODE  7'b0110011
  `define OR_FUNCT3  3'b110
  `define OR_FUNCT7  7'b0000000 
  `define XOR_OPCODE 7'b0110011
  `define XOR_FUNCT3 3'b100
  `define XOR_FUNCT7 7'b0000000 
  `define SLT_OPCODE 7'b0110011
  `define SLT_FUNCT3 3'b010 
  `define SLT_FUNCT7 7'b0000000 
  `define SLTU_OPCODE 7'b0110011
  `define SLTU_FUNCT3 3'b011 
  `define SLTU_FUNCT7 7'b0000000 

  `define SRA_OPCODE 7'b0110011 
  `define SRA_FUNCT3 3'b101 
  `define SRA_FUNCT7 7'b0100000 
  `define SRL_OPCODE 7'b0110011 
  `define SRL_FUNCT3  3'b101
  `define SRL_FUNCT7  7'b0000000 
  `define SLL_OPCODE  7'b0110011 
  `define SLL_FUNCT3  3'b001
  `define SLL_FUNCT7  7'b0000000 
  `define MUL_OPCODE 7'b0110011 
  `define MUL_FUNCT3 3'b000 
  `define MUL_FUNCT7  7'b0000001   
  

  `define ADDI_OPCODE 7'b0010011   
  `define ADDI_FUNCT3 3'b000 
  `define ANDI_OPCODE 7'b0010011 
  `define ANDI_FUNCT3 3'b111
  `define ORI_OPCODE 7'b0010011 
  `define ORI_FUNCT3 3'b110 
  `define XORI_OPCODE 7'b0010011  
  `define XORI_FUNCT3 3'b100 
  `define SLTI_OPCODE 7'b0010011  
  `define SLTI_FUNCT3  3'b010 
  `define SLTIU_OPCODE 7'b0010011 
  `define SLTIU_FUNCT3  3'b011 

  `define SRAI_OPCODE  7'b0010011  
  `define SRAI_FUNCT3   3'b101 
  `define SRAI_FUNCT7  7'b0100000 
  `define SRLI_OPCODE  7'b0010011   
  `define SRLI_FUNCT3  3'b101 
  `define SRLI_FUNCT7  7'b0000000 

  `define SLLI_OPCODE 7'b0010011
  `define SLLI_FUNCT3  3'b001 
  `define SLLI_FUNCT7  7'b0000000   
  `define LUI_OPCODE 7'b0110111 

  `define AUIPC_OPCODE  7'b0010111  

  `define LW_OPCODE  7'b0000011 
  `define LW_FUNCT3  3'b010  
  `define SW_OPCODE 7'b0100011 
  `define SW_FUNCT3 3'b010 

  `define JAL_OPCODE 7'b1101111 
  `define JR_OPCODE  7'b1100111  
  `define JR_FUNCT3 3'b000
  `define JR_10MSB 10'b000000000000    
  `define JALR_OPCODE 7'b1100111    
  `define JALR_FUNCT3  3'b000 

  `define BEQ_OPCODE 7'b1100011  
  `define BEQ_FUNCT3 3'b000
  `define BNE_OPCODE 7'b1100011  
  `define BNE_FUNCT3 3'b001  

  `define BLT_OPCODE 7'b1100011 
  `define BLT_FUNCT3 3'b100
  `define BGE_OPCODE 7'b1100011  
  `define BGE_FUNCT3 3'b101 
  `define BLTU_OPCODE 7'b1100011
  `define BLTU_FUNCT3 3'b110
  `define BGEU_OPCODE 7'b1100011
  `define BGEU_FUNCT3 3'b111 
 
  `define CSR_PROC2MNGR 0x7C0
  `define CSR_MNGR2PROC 0xFC0
  `define CSR_COREID 0xF14
  `define CSR_NUMCORES 0xFC1
  `define CSR_STATS_EN 0x7C1 


  `define UNUSED_PARAM(x)  

  `define UNUSED_VAR(x) 

`define UNUSED_PIN(x)  


/** please update the following define with your own values */ 

  `define FE_latch_WIDTH   169
  `define DE_latch_WIDTH   281
  `define AGEX_latch_WIDTH 175
  `define MEM_latch_WIDTH  173

  `define from_DE_to_FE_WIDTH  1 
  `define from_AGEX_to_FE_WIDTH 107
  `define from_MEM_to_FE_WIDTH 1
  `define from_WB_to_FE_WIDTH 1

  `define from_AGEX_to_DE_WIDTH 1 
  `define from_MEM_to_DE_WIDTH  1
  `define from_WB_to_DE_WIDTH  38 

  `define from_MEM_to_AGEX_WIDTH  1
  `define from_WB_to_AGEX_WIDTH  1

  `define from_WB_to_MEM_WIDTH 1



  
`endif 
```

```edit
./fe_stage.v
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
  input wire [`from_MEM_to_FE_WIDTH-1:0] from_MEM_to_FE,   
  input wire [`from_WB_to_FE_WIDTH-1:0] from_WB_to_FE, 
  output wire [`FE_latch_WIDTH-1:0] FE_latch_out
);

  `UNUSED_VAR (from_MEM_to_FE)
  `UNUSED_VAR (from_WB_to_FE)

  // I-MEM
  (* ram_init_file = `IDMEMINITFILE *)
  reg [`DBITS-1:0] imem [`IMEMWORDS-1:0];
 
  initial begin
      $readmemh(`IDMEMINITFILE , imem);
  end

  // G-share branch predictor
  reg [7:0] BHR;
  reg [1:0] PHT [255:0];
  
  // BTB
  reg valid_BTB [15:0];
  reg [25:0] tag_BTB [15:0];
  reg [31:0] target_BTB [15:0];

  /* pipeline latch */ 
  reg [`FE_latch_WIDTH-1:0] FE_latch;  // FE latch 
  wire valid_FE;
  assign valid_FE = 1'b1;
   
  `UNUSED_VAR(valid_FE)
  reg [`DBITS-1:0] PC_FE_latch; // PC latch in the FE stage   // you could use a part of FE_latch as a PC latch as well 
  
  reg [`DBITS-1:0] inst_count_FE; /* for debugging purpose */ 
  
  wire [`DBITS-1:0] inst_count_AGEX; /* for debugging purpose. resent the instruction counter */ 

  wire [`INSTBITS-1:0] inst_FE;  // instruction value in the FE stage 
  wire [`DBITS-1:0] pcplus_FE;  // pc plus value in the FE stage 
  wire stall_pipe_FE; // signal to indicate when a front-end needs to be stall
  
  wire [`FE_latch_WIDTH-1:0] FE_latch_contents;  // the signals that will be FE latch contents 
  
  // reading instruction from imem 
  assign inst_FE = imem[PC_FE_latch[`IMEMADDRBITS-1:`IMEMWORDBITS]];  // this code works. imem is stored 4B together 
  
  // wire to send the FE latch contents to the DE stage 
  assign FE_latch_out = FE_latch; 
 
  // This is the value of "incremented PC", computed in the FE stage
  assign pcplus_FE = PC_FE_latch + `INSTSIZE;
  
  // Prediction Logic
  wire [7:0] pht_idx_FE = PC_FE_latch[9:2] ^ BHR;
  wire [1:0] pht_counter_FE = PHT[pht_idx_FE];
  wire pht_predict_taken_FE = pht_counter_FE[1];
  
  wire [3:0] btb_idx_FE = PC_FE_latch[5:2];
  wire btb_hit_FE = valid_BTB[btb_idx_FE] && (tag_BTB[btb_idx_FE] == PC_FE_latch[31:6]);
  wire [31:0] btb_target_FE = target_BTB[btb_idx_FE];

  wire [31:0] next_pc_FE = (btb_hit_FE && pht_predict_taken_FE) ? btb_target_FE : pcplus_FE;
   
   // the order of latch contents should be matched in the decode stage when we extract the contents. 
  assign FE_latch_contents = {
                                valid_FE, 
                                inst_FE, 
                                PC_FE_latch, 
                                pcplus_FE, // please feel free to add more signals such as valid bits etc. 
                                inst_count_FE,
                                pht_idx_FE,
                                next_pc_FE
                                };

  wire br_mispred_AGEX;  
  wire [`DBITS-1:0] br_target_AGEX;  
  wire update_BP_AGEX;
  wire br_taken_AGEX;
  wire [`DBITS-1:0] br_target_calc_AGEX;
  wire [`DBITS-1:0] pc_AGEX;
  wire [7:0] pht_idx_AGEX;

  assign {
    br_mispred_AGEX,
    br_target_AGEX,
    update_BP_AGEX,
    br_taken_AGEX,
    br_target_calc_AGEX,
    pc_AGEX,
    pht_idx_AGEX
  } = from_AGEX_to_FE;

  assign {
    stall_pipe_FE
  } = from_DE_to_FE[0]; 

  integer i;
  always @ (posedge clk) begin
  /* you need to extend this always block */
   if (reset) begin 
      PC_FE_latch <= `STARTPC;
      inst_count_FE <= 1;  /* inst_count starts from 1 for easy human reading. 1st fetch instructions can have 1 */ 
      BHR <= 8'b0;
      for (i = 0; i < 256; i = i + 1) PHT[i] = 2'b01;
      for (i = 0; i < 16; i = i + 1) begin
        valid_BTB[i] = 1'b0;
        tag_BTB[i] = 26'b0;
        target_BTB[i] = 32'b0;
      end
    end 
    else if (br_mispred_AGEX)
      PC_FE_latch <= br_target_AGEX;
    else if (stall_pipe_FE) 
      PC_FE_latch <= PC_FE_latch; 
    else begin 
      PC_FE_latch <= next_pc_FE;
      inst_count_FE <= inst_count_FE + 1; 
    end 
    
    // Update predictor
    if (!reset && update_BP_AGEX) begin
        // Update BHR
        BHR <= {BHR[6:0], br_taken_AGEX};
        
        // Update PHT
        if (br_taken_AGEX) begin
            if (PHT[pht_idx_AGEX] < 2'b11) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] + 2'b01;
        end else begin
            if (PHT[pht_idx_AGEX] > 2'b00) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] - 2'b01;
        end
        
        // Update BTB
        valid_BTB[pc_AGEX[5:2]] <= 1'b1;
        tag_BTB[pc_AGEX[5:2]] <= pc_AGEX[31:6];
        target_BTB[pc_AGEX[5:2]] <= br_target_calc_AGEX;
    end
  end
  

  always @ (posedge clk) begin
    if (reset) begin 
      FE_latch <= '0; 
    end else begin 
      if (br_mispred_AGEX)
        FE_latch <= '0;
      else if (stall_pipe_FE)
        FE_latch <= FE_latch; 
      else 
        FE_latch <= FE_latch_contents; 
    end  
  end

endmodule
```

```test
```submit
```
2026-02-19 23:17:48,636 INFO Wrote define.vh (5632 bytes)
2026-02-19 23:17:48,636 INFO Result for 'edit' (first 500 chars):
Wrote define.vh (5632 bytes). First 8 lines:
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
2026-02-19 23:17:48,637 INFO Wrote fe_stage.v (4918 bytes)
2026-02-19 23:17:48,637 INFO Result for 'edit' (first 500 chars):
Wrote fe_stage.v (4918 bytes). First 8 lines:
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
2026-02-19 23:17:48,638 INFO Running part4 tests ...
2026-02-19 23:17:52,237 INFO part4 summary:
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
0
Number of failed tests:
0

2026-02-19 23:17:52,237 INFO Running part2 tests ...
2026-02-19 23:18:26,179 INFO part2 summary:
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
0
Number of failed tests:
0

2026-02-19 23:18:26,180 INFO Result for 'test' (first 500 chars):
=== part4 tests ===
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
0
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part4/testall.mem


=== part2 tests ===
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
0
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part2/add.mem
TESTING: /app/assignment/test/part2/addi.mem
TESTING: /app/
2026-02-19 23:18:26,180 INFO --- Iteration 7 ---
2026-02-19 23:18:26,182 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:19:38,782 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:19:38,794 INFO Model:
```edit
./define.vh
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
  `define STARTPC   32'h200
  `define WBCOUNTERS  8
  
  //Memory mapped IO
  `define ADDRLEDR  32'hFFFFF020
  `define ADDRKEY   32'hFFFFF080
  `define ADDRSW    32'hFFFFF090

  
// address space is m 0x00000000 to 0x000fffff
  // [NOTICE] please note that both imem and dmem use the SAME "IDMEMINITFILE".
  // you need to change this line to change which test file to read 
  `define IDMEMINITFILE "test/towers/towers.mem"
  `define IMEMADDRBITS  16
  `define IMEMWORDBITS  2
  `define IMEMWORDS	  (1 << (`IMEMADDRBITS - `IMEMWORDBITS))
  `define DMEMADDRBITS  16
  `define DMEMWORDBITS  2
  `define DMEMWORDS	  (1 << (`DMEMADDRBITS - `DMEMWORDBITS))
   
  `define CSRNOBITS 4
  `define CSR_ID_BIT_MASK 12'hF // this should match with CSRNOBITS 
  `define CSRREGNUM (1 << (`CSRNOBITS))

// internal instruction opcode enumerator for easy programming 

  `define IOPBITS 6
  `define TYPENOBITS 4 
  `define IMMTYPENOBITS 3 

  `define ADD_I    1 
  `define SUB_I    2 
  `define AND_I    3
  `define OR_I     4 
  `define XOR_I    5
  `define SLT_I    6
  `define SLTU_I   7
  `define SRA_I    8
  `define SRL_I    9
  `define SLL_I    10
  `define MUL_I    11
  `define ADDI_I   12 
  `define ANDI_I   13
  `define ORI_I    14
  `define XORI_I   15
  `define SLTI_I   16
  `define SLTIU_I  17
  `define SRAI_I   18
  `define SRLI_I   19
  `define SLLI_I   20
  `define LUI_I    21
  `define AUIPC_I  22
  `define LW_I     23
  `define SW_I     24
  `define JAL_I    25
  `define JR_I     26
  `define JALR_I   27
  `define BEQ_I    28
  `define BNE_I    29
  `define BLT_I    30
  `define BGE_I    31
  `define BLTU_I   32
  `define BGEU_I   33
  `define CSRR_I  34
  `define CSRW_I  35
  `define CSR_I    36
  `define INVALID_I 37 

  `define R_Type 1 
  `define I_Type 2 
  `define S_Type 3 
  `define U_Type 4 
  `define I_I_type 5 
  `define S_I_Type 6
  `define B_I_Type 7
  `define U_I_Type 8
  `define J_I_Type 9 

  `define I_immediate 1 
  `define J_immediate 2
  `define U_immediate 3
  `define S_immediate 4 
  `define B_immediate 5  


  `define CSRR_OPCODE 7'b1110011 
  `define CSRR_FUNCT3 3'b010
  `define CSRW_OPCODE 7'b1110011 
  `define CSRW_FUNCT3 3'b001  

  `define ADD_OPCODE 7'b0110011
  `define ADD_FUNCT3 3'b000
  `define ADD_FUNCT7 7'b0000000 
  `define SUB_OPCODE 7'b0110011
  `define SUB_FUNCT3 3'b000
  `define SUB_FUNCT7 7'b0100000
  `define AND_OPCODE 7'b0110011
  `define AND_FUNCT3 3'b111
  `define AND_FUNCT7 7'b0000000 
  `define OR_OPCODE  7'b0110011
  `define OR_FUNCT3  3'b110
  `define OR_FUNCT7  7'b0000000 
  `define XOR_OPCODE 7'b0110011
  `define XOR_FUNCT3 3'b100
  `define XOR_FUNCT7 7'b0000000 
  `define SLT_OPCODE 7'b0110011
  `define SLT_FUNCT3 3'b010 
  `define SLT_FUNCT7 7'b0000000 
  `define SLTU_OPCODE 7'b0110011
  `define SLTU_FUNCT3 3'b011 
  `define SLTU_FUNCT7 7'b0000000 

  `define SRA_OPCODE 7'b0110011 
  `define SRA_FUNCT3 3'b101 
  `define SRA_FUNCT7 7'b0100000 
  `define SRL_OPCODE 7'b0110011 
  `define SRL_FUNCT3  3'b101
  `define SRL_FUNCT7  7'b0000000 
  `define SLL_OPCODE  7'b0110011 
  `define SLL_FUNCT3  3'b001
  `define SLL_FUNCT7  7'b0000000 
  `define MUL_OPCODE 7'b0110011 
  `define MUL_FUNCT3 3'b000 
  `define MUL_FUNCT7  7'b0000001   
  

  `define ADDI_OPCODE 7'b0010011   
  `define ADDI_FUNCT3 3'b000 
  `define ANDI_OPCODE 7'b0010011 
  `define ANDI_FUNCT3 3'b111
  `define ORI_OPCODE 7'b0010011 
  `define ORI_FUNCT3 3'b110 
  `define XORI_OPCODE 7'b0010011  
  `define XORI_FUNCT3 3'b100 
  `define SLTI_OPCODE 7'b0010011  
  `define SLTI_FUNCT3  3'b010 
  `define SLTIU_OPCODE 7'b0010011 
  `define SLTIU_FUNCT3  3'b011 

  `define SRAI_OPCODE  7'b0010011  
  `define SRAI_FUNCT3   3'b101 
  `define SRAI_FUNCT7  7'b0100000 
  `define SRLI_OPCODE  7'b0010011   
  `define SRLI_FUNCT3  3'b101 
  `define SRLI_FUNCT7  7'b0000000 

  `define SLLI_OPCODE 7'b0010011
  `define SLLI_FUNCT3  3'b001 
  `define SLLI_FUNCT7  7'b0000000   
  `define LUI_OPCODE 7'b0110111 

  `define AUIPC_OPCODE  7'b0010111  

  `define LW_OPCODE  7'b0000011 
  `define LW_FUNCT3  3'b010  
  `define SW_OPCODE 7'b0100011 
  `define SW_FUNCT3 3'b010 

  `define JAL_OPCODE 7'b1101111 
  `define JR_OPCODE  7'b1100111  
  `define JR_FUNCT3 3'b000
  `define JR_10MSB 10'b000000000000    
  `define JALR_OPCODE 7'b1100111    
  `define JALR_FUNCT3  3'b000 

  `define BEQ_OPCODE 7'b1100011  
  `define BEQ_FUNCT3 3'b000
  `define BNE_OPCODE 7'b1100011  
  `define BNE_FUNCT3 3'b001  

  `define BLT_OPCODE 7'b1100011 
  `define BLT_FUNCT3 3'b100
  `define BGE_OPCODE 7'b1100011  
  `define BGE_FUNCT3 3'b101 
  `define BLTU_OPCODE 7'b1100011
  `define BLTU_FUNCT3 3'b110
  `define BGEU_OPCODE 7'b1100011
  `define BGEU_FUNCT3 3'b111 
 
  `define CSR_PROC2MNGR 0x7C0
  `define CSR_MNGR2PROC 0xFC0
  `define CSR_COREID 0xF14
  `define CSR_NUMCORES 0xFC1
  `define CSR_STATS_EN 0x7C1 


  `define UNUSED_PARAM(x)  

  `define UNUSED_VAR(x) 

`define UNUSED_PIN(x)  


/** please update the following define with your own values */ 

  `define FE_latch_WIDTH   169
  `define DE_latch_WIDTH   281
  `define AGEX_latch_WIDTH 175
  `define MEM_latch_WIDTH  173

  `define from_DE_to_FE_WIDTH  1 
  `define from_AGEX_to_FE_WIDTH 107
  `define from_MEM_to_FE_WIDTH 1
  `define from_WB_to_FE_WIDTH 1

  `define from_AGEX_to_DE_WIDTH 1 
  `define from_MEM_to_DE_WIDTH  1
  `define from_WB_to_DE_WIDTH  38 

  `define from_MEM_to_AGEX_WIDTH  1
  `define from_WB_to_AGEX_WIDTH  1

  `define from_WB_to_MEM_WIDTH 1



  
`endif 
```
```edit
./fe_stage.v
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
  input wire [`from_MEM_to_FE_WIDTH-1:0] from_MEM_to_FE,   
  input wire [`from_WB_to_FE_WIDTH-1:0] from_WB_to_FE, 
  output wire [`FE_latch_WIDTH-1:0] FE_latch_out
);

  `UNUSED_VAR (from_MEM_to_FE)
  `UNUSED_VAR (from_WB_to_FE)

  // I-MEM
  (* ram_init_file = `IDMEMINITFILE *)
  reg [`DBITS-1:0] imem [`IMEMWORDS-1:0];
 
  initial begin
      $readmemh(`IDMEMINITFILE , imem);
  end

  // G-share branch predictor
  reg [7:0] BHR;
  reg [1:0] PHT [255:0];
  
  // BTB
  reg valid_BTB [15:0];
  reg [25:0] tag_BTB [15:0];
  reg [31:0] target_BTB [15:0];

  /* pipeline latch */ 
  reg [`FE_latch_WIDTH-1:0] FE_latch;  // FE latch 
  wire valid_FE;
  assign valid_FE = 1'b1;
   
  `UNUSED_VAR(valid_FE)
  reg [`DBITS-1:0] PC_FE_latch; // PC latch in the FE stage   // you could use a part of FE_latch as a PC latch as well 
  
  reg [`DBITS-1:0] inst_count_FE; /* for debugging purpose */ 
  
  wire [`DBITS-1:0] inst_count_AGEX; /* for debugging purpose. resent the instruction counter */ 

  wire [`INSTBITS-1:0] inst_FE;  // instruction value in the FE stage 
  wire [`DBITS-1:0] pcplus_FE;  // pc plus value in the FE stage 
  wire stall_pipe_FE; // signal to indicate when a front-end needs to be stall
  
  wire [`FE_latch_WIDTH-1:0] FE_latch_contents;  // the signals that will be FE latch contents 
  
  // reading instruction from imem 
  assign inst_FE = imem[PC_FE_latch[`IMEMADDRBITS-1:`IMEMWORDBITS]];  // this code works. imem is stored 4B together 
  
  // wire to send the FE latch contents to the DE stage 
  assign FE_latch_out = FE_latch; 
 
  // This is the value of "incremented PC", computed in the FE stage
  assign pcplus_FE = PC_FE_latch + `INSTSIZE;
  
  // Prediction Logic
  wire [7:0] pht_idx_FE = PC_FE_latch[9:2] ^ BHR;
  wire [1:0] pht_counter_FE = PHT[pht_idx_FE];
  wire pht_predict_taken_FE = pht_counter_FE[1];
  
  wire [3:0] btb_idx_FE = PC_FE_latch[5:2];
  wire btb_hit_FE = valid_BTB[btb_idx_FE] && (tag_BTB[btb_idx_FE] == PC_FE_latch[31:6]);
  wire [31:0] btb_target_FE = target_BTB[btb_idx_FE];

  wire [31:0] next_pc_FE = (btb_hit_FE && pht_predict_taken_FE) ? btb_target_FE : pcplus_FE;
   
   // the order of latch contents should be matched in the decode stage when we extract the contents. 
  assign FE_latch_contents = {
                                valid_FE, 
                                inst_FE, 
                                PC_FE_latch, 
                                pcplus_FE, // please feel free to add more signals such as valid bits etc. 
                                inst_count_FE,
                                pht_idx_FE,
                                next_pc_FE
                                };

  wire br_mispred_AGEX;  
  wire [`DBITS-1:0] br_target_AGEX;  
  wire update_BP_AGEX;
  wire br_taken_AGEX;
  wire [`DBITS-1:0] br_target_calc_AGEX;
  wire [`DBITS-1:0] pc_AGEX;
  wire [7:0] pht_idx_AGEX;

  assign {
    br_mispred_AGEX,
    br_target_AGEX,
    update_BP_AGEX,
    br_taken_AGEX,
    br_target_calc_AGEX,
    pc_AGEX,
    pht_idx_AGEX
  } = from_AGEX_to_FE;

  assign {
    stall_pipe_FE
  } = from_DE_to_FE[0]; 

  integer i;
  always @ (posedge clk) begin
  /* you need to extend this always block */
   if (reset) begin 
      PC_FE_latch <= `STARTPC;
      inst_count_FE <= 1;  /* inst_count starts from 1 for easy human reading. 1st fetch instructions can have 1 */ 
      BHR <= 8'b0;
      for (i = 0; i < 256; i = i + 1) PHT[i] = 2'b01;
      for (i = 0; i < 16; i = i + 1) begin
        valid_BTB[i] = 1'b0;
        tag_BTB[i] = 26'b0;
        target_BTB[i] = 32'b0;
      end
    end 
    else if (br_mispred_AGEX)
      PC_FE_latch <= br_target_AGEX;
    else if (stall_pipe_FE) 
      PC_FE_latch <= PC_FE_latch; 
    else begin 
      PC_FE_latch <= next_pc_FE;
      inst_count_FE <= inst_count_FE + 1; 
    end 
    
    // Update predictor
    if (!reset && update_BP_AGEX) begin
        // Update BHR
        BHR <= {BHR[6:0], br_taken_AGEX};
        
        // Update PHT
        if (br_taken_AGEX) begin
            if (PHT[pht_idx_AGEX] < 2'b11) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] + 2'b01;
        end else begin
            if (PHT[pht_idx_AGEX] > 2'b00) PHT[pht_idx_AGEX] <= PHT[pht_idx_AGEX] - 2'b01;
        end
        
        // Update BTB
        valid_BTB[pc_AGEX[5:2]] <= 1'b1;
        tag_BTB[pc_AGEX[5:2]] <= pc_AGEX[31:6];
        target_BTB[pc_AGEX[5:2]] <= br_target_calc_AGEX;
    end
  end
  

  always @ (posedge clk) begin
    if (reset) begin 
      FE_latch <= '0; 
    end else begin 
      if (br_mispred_AGEX)
        FE_latch <= '0;
      else if (stall_pipe_FE)
        FE_latch <= FE_latch; 
      else 
        FE_latch <= FE_latch_contents; 
    end  
  end

endmodule
```
```edit
./sim_main.cpp
// DESCRIPTION:  simulation of pipeline 
//======================================================================
#include <iostream>

// Include common routines
#include <verilated.h>
// Include model header, generated from Verilating "pipeline.v"
#include "Vpipeline.h"
#include "Vpipeline__Syms.h"

#ifdef VCD_OUTPUT
#include <verilated_vcd_c.h>
#endif

#define RUN_CYCLES 100000

#define CLOCK_PERIOD 2

#define RESET_TIME  10

// Current simulation time (64-bit unsigned)
uint64_t timestamp = 0;

double sc_time_stamp() { 
  return timestamp;
}

int main(int argc, char** argv, char** env) {
    // turn off unused variable warnings
    if (0 && argc && argv && env) {}

    // Construct the Verilated model
    Vpipeline* dut = new Vpipeline();

#ifdef VCD_OUTPUT
    Verilated::traceEverOn(true);
    auto trace = new VerilatedVcdC();
    dut->trace(trace, 2999);
    trace->open("trace.vcd");
#endif

#ifdef DPRINTF
    uint64_t inst_count_WB = 0;
    uint64_t timestamp_WB = 0;
#endif

    dut->clk = 0;
    dut->reset = 0;

    while (timestamp < RUN_CYCLES) {      
        bool clk_transition = (timestamp % CLOCK_PERIOD) == 0;
        if (clk_transition) 
            dut->clk = !dut->clk; 

        if (timestamp > 1 && timestamp < RESET_TIME) {
            dut->reset = 1;  // Assert reset
        } else {
            dut->reset = 0;  // Deassert reset
        }
        
        // Evaluate model
        dut->eval();

    #ifdef DPRINTF 
        // Verilator allows to access verilator public data structure
        if (clk_transition && dut->clk) {
            bool valid_WB = (int)dut->pipeline->my_WB_stage->WB_counters[0] != 0;
            if (valid_WB)  { 
                ++inst_count_WB;
                timestamp_WB = timestamp - RESET_TIME;
            }
        }

    #endif

    #ifdef VCD_OUTPUT
        trace->dump(timestamp);
    #endif
        ++timestamp;
    }

#ifdef DPRINTF
    std::cout << "Total instructions=" << std::dec << inst_count_WB << ", cycles=" << (timestamp_WB / 2) << ", IPC=" << ((inst_count_WB * 2.0f) / timestamp_WB) << std::endl; 
#endif

    uint32_t bp_correct = dut->pipeline->my_AGEX_stage->bp_correct_cnt;
    uint32_t bp_total = dut->pipeline->my_AGEX_stage->bp_total_cnt;
    double accuracy = 0.0;
    if (bp_total > 0) accuracy = 100.0 * (double)bp_correct / (double)bp_total;
    std::cout << "Accuracy=" << accuracy << "%" << std::endl;

    int exitcode = (int)dut->pipeline->my_WB_stage->last_WB_value[3];

    // Final model cleanup
    dut->final();

#ifdef VCD_OUTPUT
    trace->close();
    delete trace;
#endif

    // Destroy DUT
    delete dut;

    // TinyRV1 test Pass/Fail status
    if (1 == exitcode)
        std::cout<<"Passed!"<<std::endl;
    else
        std::cout<<"Simulation Finished. exitcode: "<<exitcode<<std::endl;

    // Fin
    exit(0);
}
```
```test
```submit
```
2026-02-19 23:19:38,795 INFO Wrote define.vh (5632 bytes)
2026-02-19 23:19:38,795 INFO Result for 'edit' (first 500 chars):
Wrote define.vh (5632 bytes). First 8 lines:
`ifndef DEFINE_H
`define DEFINE_H

  `define DBITS     32
  `define INSTSIZE  32'd4
  `define INSTBITS  32
  `define REGWORDS  32 
  `define REGNOBITS  5
2026-02-19 23:19:38,796 INFO Wrote fe_stage.v (4918 bytes)
2026-02-19 23:19:38,796 INFO Result for 'edit' (first 500 chars):
Wrote fe_stage.v (4918 bytes). First 8 lines:
 `include "define.vh" 


module FE_STAGE(
  input wire clk,
  input wire reset,
  input wire [`from_DE_to_FE_WIDTH-1:0] from_DE_to_FE,
  input wire [`from_AGEX_to_FE_WIDTH-1:0] from_AGEX_to_FE,   
2026-02-19 23:19:38,796 INFO Wrote sim_main.cpp (2835 bytes)
2026-02-19 23:19:38,796 INFO Result for 'edit' (first 500 chars):
Wrote sim_main.cpp (2835 bytes). First 8 lines:
// DESCRIPTION:  simulation of pipeline 
//======================================================================
#include <iostream>

// Include common routines
#include <verilated.h>
// Include model header, generated from Verilating "pipeline.v"
#include "Vpipeline.h"
2026-02-19 23:19:38,796 INFO Running part4 tests ...
2026-02-19 23:19:41,613 INFO part4 summary:
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

2026-02-19 23:19:41,613 INFO Running part2 tests ...
2026-02-19 23:20:06,974 INFO part2 summary:
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

2026-02-19 23:20:06,974 INFO Result for 'test' (first 500 chars):
=== part4 tests ===
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part4/testall.mem
Passed!


=== part2 tests ===
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part2/add.mem
Passed!
TESTING: /app/assignment/test/part2/addi.m
2026-02-19 23:20:06,974 INFO --- Iteration 8 ---
2026-02-19 23:20:06,975 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:20:11,563 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:20:11,566 INFO Model:
```test
```

```submit
```
2026-02-19 23:20:11,566 INFO Running part4 tests ...
2026-02-19 23:20:14,275 INFO part4 summary:
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

2026-02-19 23:20:14,276 INFO Running part2 tests ...
2026-02-19 23:20:39,855 INFO part2 summary:
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

2026-02-19 23:20:39,855 INFO Result for 'test' (first 500 chars):
=== part4 tests ===
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part4/testall.mem
Passed!


=== part2 tests ===
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part2/add.mem
Passed!
TESTING: /app/assignment/test/part2/addi.m
2026-02-19 23:20:39,855 INFO --- Iteration 9 ---
2026-02-19 23:20:39,856 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:20:51,806 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:20:51,809 INFO Model:
```edit
./run_tests.sh
#!/bin/bash


part=$1

echo You have chosen to run $part tests

case $part in 
  part1) 
    rm -f part1_tests.log
    ;;
  part2) 
    rm -f part2_tests.log
    ;;
  part3) 
    rm -f part3_tests.log
    ;;
  part4) 
    rm -f part4_tests.log
    ;;
  towers)
    rm -f towers_tests.log
	;;
esac

case $part in
	part1)
		echo RUNNING PART1$'\n'
		for filename in $PWD/test/part1/*.mem;do
			echo $'\n'TESTING: $filename >> part1_tests.log
			IDMEMINITFILE=$filename make tests>> part1_tests.log
		done
		grep -E 'TESTING|Failed|Passed' part1_tests.log>part1_results.log
		echo "Total number of tests:"
		grep -i testing part1_tests.log | wc -l
		echo "Number of passed tests:"
		grep -i passed part1_tests.log | wc -l
		echo "Number of failed tests:"
		grep -i failed part1_tests.log | wc -l
	;;
	part2)
		echo RUNNING PART2$'\n'
		for filename in $PWD/test/part2/*.mem;do
			echo $'\n'TESTING: $filename >> part2_tests.log
			IDMEMINITFILE=$filename make tests>> part2_tests.log
		done
		grep -E 'TESTING|Failed|Passed' part2_tests.log>part2_results.log
		echo "Total number of tests:"
		grep -i testing part2_tests.log | wc -l
		echo "Number of passed tests:"
		grep -i passed part2_tests.log | wc -l
		echo "Number of failed tests:"
		grep -i failed part2_tests.log | wc -l
	;;
	part3)
		echo RUNNING PART3$'\n'
		for filename in $PWD/test/part3/*.mem;do
			echo $'\n'TESTING: $filename >> part3_tests.log
			IDMEMINITFILE=$filename make tests>> part3_tests.log
		done
		grep -E 'TESTING|Failed|Passed' part3_tests.log>part3_results.log
		echo "Total number of tests:"
		grep -i testing part3_tests.log | wc -l
		echo "Number of passed tests:"
		grep -i passed part3_tests.log | wc -l
		echo "Number of failed tests:"
		grep -i failed part3_tests.log | wc -l
	;;
	part4)
			echo RUNNING PART4$'\n'
			for filename in $PWD/test/part4/*.mem;do
					echo $'\n'TESTING: $filename >> part4_tests.log
					IDMEMINITFILE=$filename make tests>> part4_tests.log
			done
			grep -E 'TESTING|Failed|Passed' part4_tests.log>part4_results.log
			echo "Total number of tests:"
			grep -i testing part4_tests.log | wc -l
			echo "Number of passed tests:"
			grep -i passed part4_tests.log | wc -l
			echo "Number of failed tests:"
			grep -i failed part4_tests.log | wc -l
	;;
	towers)
		echo RUNNING TOWERS$'\n'
		for filename in $PWD/test/towers/*.mem;do
			echo $'\n'TESTING: $filename >> towers_tests.log
			IDMEMINITFILE=$filename make tests >> towers_tests.log
		done
		grep -E 'TESTING|Accuracy' towers_tests.log
	;;
	all)
		echo RUNNING ALL$'\n'
		for filename in $PWD/test/part*/*.vmh;do
			echo $'\n'TESTING: $filename >> all_tests.log
			IDMEMINITFILE=$filename make tests>> all_tests.log
		done
		grep -E 'TESTING|Failed|Passed' all_tests.log>all_results.log
		echo "Total number of tests:"
		grep -i testing part3_tests.log | wc -l
		echo "Number of passed tests:"
		grep -i passed part3_tests.log | wc -l
		echo "Number of failed tests:"
		grep -i failed part3_tests.log | wc -l
	;;
	*)
		echo INVALID PART. Use part1, part2, part3, part4 or all as command line argument
	;;
esac
```

```test
```

```submit
```
2026-02-19 23:20:51,810 INFO Wrote run_tests.sh (3083 bytes)
2026-02-19 23:20:51,810 INFO Result for 'edit' (first 500 chars):
Wrote run_tests.sh (3083 bytes). First 8 lines:
#!/bin/bash


part=$1

echo You have chosen to run $part tests

case $part in 
2026-02-19 23:20:51,811 INFO Running part4 tests ...
2026-02-19 23:20:54,517 INFO part4 summary:
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

2026-02-19 23:20:54,517 INFO Running part2 tests ...
2026-02-19 23:21:22,210 INFO part2 summary:
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

2026-02-19 23:21:22,210 INFO Result for 'test' (first 500 chars):
=== part4 tests ===
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part4/testall.mem
Passed!


=== part2 tests ===
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part2/add.mem
Passed!
TESTING: /app/assignment/test/part2/addi.m
2026-02-19 23:21:22,211 INFO --- Iteration 10 ---
2026-02-19 23:21:22,211 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:21:29,899 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:21:29,902 INFO Model:
```test
```

```submit
```
2026-02-19 23:21:29,902 INFO Running part4 tests ...
2026-02-19 23:21:32,810 INFO part4 summary:
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

2026-02-19 23:21:32,811 INFO Running part2 tests ...
2026-02-19 23:22:00,877 INFO part2 summary:
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

2026-02-19 23:22:00,877 INFO Result for 'test' (first 500 chars):
=== part4 tests ===
You have chosen to run part4 tests
RUNNING PART4

Total number of tests:
1
Number of passed tests:
1
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part4/testall.mem
Passed!


=== part2 tests ===
You have chosen to run part2 tests
RUNNING PART2

Total number of tests:
10
Number of passed tests:
10
Number of failed tests:
0

--- per-test results ---
TESTING: /app/assignment/test/part2/add.mem
Passed!
TESTING: /app/assignment/test/part2/addi.m
2026-02-19 23:22:00,877 INFO --- Iteration 11 ---
2026-02-19 23:22:00,879 INFO AFC is enabled with max remote calls: 10.
2026-02-19 23:22:03,881 INFO HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent "HTTP/1.1 200 OK"
2026-02-19 23:22:03,885 INFO Model:
```submit
```
2026-02-19 23:22:03,885 INFO === SUBMITTED  agent complete ===
2026-02-19 23:22:03,885 INFO ============================================================
2026-02-19 23:22:03,886 INFO Cost Summary
2026-02-19 23:22:03,886 INFO ============================================================
2026-02-19 23:22:03,887 INFO   gemini-3.1-pro-preview                2 calls    29,458 in     4,397 out  $0.05881
2026-02-19 23:22:03,887 INFO   gemini-3-flash-preview               11 calls   800,294 in    53,673 out  $0.07612
2026-02-19 23:22:03,887 INFO   TOTAL                                         829,752 in    58,070 out  $0.13493
2026-02-19 23:22:03,890 INFO Cost report written to /output/costs.json
2026-02-19 23:22:04,289 INFO Final assignment files copied to /output/assignment
2026-02-19 23:22:04,289 INFO ============================================================
2026-02-19 23:22:04,289 INFO Lab Agent finished
2026-02-19 23:22:04,289 INFO ============================================================
